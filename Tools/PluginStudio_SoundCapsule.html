<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Plugin Studio â€” Sound Capsule / Plugin Corp</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;600;700;800&display=swap"
    rel="stylesheet">
  <!-- JSZip for bundling export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0
    }

    :root {
      --bg: #111318;
      --surface: #181c24;
      --surface2: #1e2330;
      --surface3: #252b3a;
      --border: #2a3045;
      --border2: #323d56;
      --text: #e2e6f0;
      --muted: #5a6480;
      --muted2: #8892aa;
      --accent: #4f8aff;
      --accent2: #00d4aa;
      --accent3: #ff6b6b;
      --sidebar: 218px;
      --inspector: 262px;
      --toolbar: 52px;
    }

    body {
      font-family: 'Syne', sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-size: 13px;
      user-select: none;
    }

    /* TOOLBAR */
    #toolbar {
      height: var(--toolbar);
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 14px;
      gap: 9px;
      flex-shrink: 0;
      z-index: 200;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-right: 2px;
    }

    .logo-mark {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border-radius: 7px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 800;
      color: #fff;
    }

    .logo-text {
      font-size: 13px;
      font-weight: 700;
    }

    .logo-sub {
      font-size: 10px;
      color: var(--muted);
    }

    .tb-sep {
      width: 1px;
      height: 22px;
      background: var(--border2);
      margin: 0 2px;
    }

    .tb-btn {
      background: transparent;
      border: 1px solid var(--border2);
      color: var(--muted2);
      padding: 5px 11px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'Syne', sans-serif;
      font-size: 11px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: all 0.15s;
    }

    .tb-btn:hover {
      background: var(--surface3);
      color: var(--text);
    }

    .tb-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .tb-btn.primary:hover {
      background: #3a75ee;
    }

    #brand-switcher {
      display: flex;
      gap: 5px;
    }

    .brand-pill {
      padding: 4px 12px;
      border-radius: 20px;
      border: 1px solid var(--border2);
      cursor: pointer;
      font-size: 11px;
      font-weight: 700;
      color: var(--muted2);
      transition: all 0.15s;
      background: transparent;
      font-family: 'Syne', sans-serif;
    }

    .brand-pill:hover {
      color: var(--text);
    }

    .brand-pill.active {
      color: #fff;
      border-color: transparent;
    }

    #tb-plugin-name {
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      color: var(--muted);
      margin: 0 auto;
    }

    /* LAYOUT */
    #main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* SIDEBAR */
    #sidebar {
      width: var(--sidebar);
      background: var(--surface);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .sec {
      border-bottom: 1px solid var(--border);
      padding: 10px 10px 8px;
    }

    .sec-title {
      font-family: 'Space Mono', monospace;
      font-size: 9px;
      font-weight: 700;
      color: var(--muted);
      letter-spacing: .14em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .add-row {
      display: flex;
      gap: 5px;
      margin-bottom: 7px;
    }

    .add-btn {
      flex: 1;
      background: var(--surface3);
      border: 1px dashed var(--border2);
      color: var(--muted);
      padding: 6px 4px;
      border-radius: 7px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      text-align: center;
      transition: all .15s;
      font-family: 'Syne', sans-serif;
    }

    .add-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .ctrl-row {
      display: flex;
      align-items: center;
      gap: 7px;
      padding: 5px 6px;
      border-radius: 7px;
      cursor: pointer;
      transition: background .1s;
      margin-bottom: 2px;
    }

    .ctrl-row:hover {
      background: var(--surface3);
    }

    .ctrl-row.sel {
      background: rgba(79, 138, 255, .15);
      border: 1px solid rgba(79, 138, 255, .2);
    }

    .ctrl-icon {
      font-size: 13px;
      width: 18px;
      text-align: center;
      opacity: .7;
    }

    .ctrl-meta {
      flex: 1;
      min-width: 0;
    }

    .ctrl-name {
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .ctrl-pid {
      font-family: 'Space Mono', monospace;
      font-size: 9px;
      color: var(--muted);
    }

    .ctrl-del {
      opacity: 0;
      color: var(--accent3);
      font-size: 10px;
      padding: 2px 4px;
      cursor: pointer;
    }

    .ctrl-row:hover .ctrl-del {
      opacity: 1;
    }

    .srow {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 5px;
    }

    .slbl {
      font-size: 11px;
      color: var(--muted2);
      width: 68px;
      flex-shrink: 0;
    }

    .sinp {
      flex: 1;
      background: var(--surface3);
      border: 1px solid var(--border2);
      border-radius: 5px;
      color: var(--text);
      padding: 4px 7px;
      font-family: 'Syne', sans-serif;
      font-size: 11px;
      outline: none;
    }

    .sinp:focus {
      border-color: var(--accent);
    }

    .sinp[type=color] {
      padding: 2px;
      height: 26px;
      cursor: pointer;
    }

    .sseg {
      display: flex;
      flex: 1;
      background: var(--surface3);
      border: 1px solid var(--border2);
      border-radius: 5px;
      overflow: hidden;
    }

    .sseg-b {
      flex: 1;
      padding: 4px;
      text-align: center;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      background: none;
      border: none;
      color: var(--muted);
      font-family: 'Syne', sans-serif;
    }

    .sseg-b.on {
      background: var(--accent);
      color: #fff;
    }

    /* locked badge */
    .locked-badge {
      font-family: 'Space Mono', monospace;
      font-size: 8px;
      color: var(--accent2);
      background: rgba(0, 212, 170, .12);
      border: 1px solid rgba(0, 212, 170, .25);
      border-radius: 4px;
      padding: 1px 5px;
      margin-left: 4px;
      letter-spacing: .06em;
    }

    /* CANVAS */
    #canvas-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #090b0f;
      background-image: radial-gradient(ellipse at 40% 40%, #10141e 0%, #050709 100%);
      overflow: auto;
      position: relative;
    }

    #plugin-canvas {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      flex-shrink: 0;
      box-shadow: 0 30px 80px rgba(0, 0, 0, .85), 0 0 0 1px rgba(255, 255, 255, .05);
    }

    #cvs-bg,
    #cvs-grid,
    #cvs-snap {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    #cvs-ctrls {
      position: absolute;
      inset: 0;
    }

    .plg-name {
      position: absolute;
      top: 13px;
      left: 16px;
      font-family: 'Space Mono', monospace;
      font-size: 13px;
      font-weight: 700;
      color: rgba(255, 255, 255, .82);
      pointer-events: none;
      z-index: 10;
    }

    .plg-co {
      position: absolute;
      top: 15px;
      right: 16px;
      font-family: 'Space Mono', monospace;
      font-size: 9px;
      color: rgba(255, 255, 255, .38);
      pointer-events: none;
      z-index: 10;
    }

    .cc {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: grab;
      z-index: 5;
    }

    .cc:active {
      cursor: grabbing;
    }

    .cc .sel-ring {
      position: absolute;
      inset: -5px;
      border: 1.5px solid rgba(79, 138, 255, .85);
      border-radius: 8px;
      opacity: 0;
      pointer-events: none;
    }

    .cc.sel .sel-ring {
      opacity: 1;
    }

    .cc .lbl-txt {
      font-family: 'Space Mono', monospace;
      margin-top: 3px;
      pointer-events: none;
      white-space: nowrap;
    }

    /* INSPECTOR */
    #inspector {
      width: var(--inspector);
      background: var(--surface);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .isec {
      border-bottom: 1px solid var(--border);
      padding: 10px 12px;
    }

    .irow {
      display: flex;
      align-items: center;
      gap: 7px;
      margin-bottom: 6px;
    }

    .ilbl {
      font-size: 11px;
      color: var(--muted2);
      width: 76px;
      flex-shrink: 0;
    }

    .iinp {
      flex: 1;
      background: var(--surface3);
      border: 1px solid var(--border2);
      border-radius: 5px;
      color: var(--text);
      padding: 4px 7px;
      font-family: 'Syne', sans-serif;
      font-size: 12px;
      outline: none;
    }

    .iinp:focus {
      border-color: var(--accent);
    }

    .iinp[type=color] {
      padding: 2px;
      height: 26px;
      cursor: pointer;
    }

    .iinp[type=range] {
      padding: 0;
      height: 4px;
      accent-color: var(--accent);
      cursor: pointer;
    }

    .iseg {
      display: flex;
      flex: 1;
      background: var(--surface3);
      border: 1px solid var(--border2);
      border-radius: 5px;
      overflow: hidden;
    }

    .iseg-b {
      flex: 1;
      padding: 4px 2px;
      text-align: center;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      background: none;
      border: none;
      color: var(--muted);
      font-family: 'Syne', sans-serif;
    }

    .iseg-b.on {
      background: var(--accent);
      color: #fff;
    }

    .kp-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
      margin-top: 5px;
    }

    .kp-opt {
      border: 2px solid var(--border2);
      border-radius: 8px;
      padding: 4px 3px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      background: var(--surface3);
      transition: all .15s;
    }

    .kp-opt:hover {
      border-color: var(--muted2);
    }

    .kp-opt.on {
      border-color: var(--accent);
    }

    .kp-opt svg {
      width: 36px;
      height: 36px;
    }

    .kp-lbl {
      font-size: 8px;
      color: var(--muted);
      font-weight: 700;
      text-align: center;
    }

    .tp-row {
      display: flex;
      gap: 6px;
      margin-top: 5px;
    }

    .tp-opt {
      flex: 1;
      border: 2px solid var(--border2);
      border-radius: 7px;
      padding: 6px 3px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
      background: var(--surface3);
      transition: all .15s;
    }

    .tp-opt:hover {
      border-color: var(--muted2);
    }

    .tp-opt.on {
      border-color: var(--accent);
    }

    .tp-lbl {
      font-size: 9px;
      color: var(--muted);
      font-weight: 700;
    }

    .danger-btn {
      width: 100%;
      background: rgba(255, 107, 107, .1);
      border: 1px solid rgba(255, 107, 107, .3);
      color: var(--accent3);
      padding: 7px;
      border-radius: 7px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      font-family: 'Syne', sans-serif;
      transition: all .15s;
    }

    .danger-btn:hover {
      background: rgba(255, 107, 107, .2);
    }

    #no-sel {
      padding: 24px 14px;
      text-align: center;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.7;
    }

    /* Param range rows */
    .irow-range {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 6px;
    }

    .iinp-sm {
      width: 54px;
      background: var(--surface3);
      border: 1px solid var(--border2);
      border-radius: 5px;
      color: var(--text);
      padding: 4px 5px;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      outline: none;
      text-align: center;
    }

    .iinp-sm:focus {
      border-color: var(--accent);
    }

    .range-sep {
      color: var(--muted);
      font-size: 10px;
    }

    /* MODAL */
    #modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .82);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    #modal.open {
      display: flex;
    }

    .mbox {
      background: var(--surface);
      border: 1px solid var(--border2);
      border-radius: 14px;
      padding: 26px;
      width: 580px;
      max-height: 88vh;
      display: flex;
      flex-direction: column;
      gap: 13px;
      overflow-y: auto;
    }

    .mtitle {
      font-size: 16px;
      font-weight: 800;
      color: var(--accent2);
    }

    .minfo {
      font-size: 12px;
      color: var(--muted2);
      line-height: 1.7;
    }

    .frow {
      background: var(--surface3);
      border: 1px solid var(--border2);
      border-radius: 9px;
      padding: 8px 14px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .fname {
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      color: var(--accent2);
      flex: 1;
    }

    .fsize {
      font-size: 10px;
      color: var(--muted);
    }

    .fdesc {
      font-size: 10px;
      color: var(--muted2);
    }

    .cmd-box {
      background: var(--bg);
      border: 1px solid var(--border2);
      border-radius: 8px;
      padding: 12px 14px;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      color: var(--accent2);
      white-space: pre;
      cursor: text;
      position: relative;
    }

    .mclose {
      background: var(--surface3);
      border: 1px solid var(--border2);
      color: var(--text);
      padding: 8px 22px;
      border-radius: 7px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      font-family: 'Syne', sans-serif;
    }

    .mclose:hover {
      background: var(--surface2);
    }

    .mzip {
      background: var(--accent2);
      border: none;
      color: #000;
      padding: 8px 22px;
      border-radius: 7px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 800;
      font-family: 'Syne', sans-serif;
      transition: all .15s;
    }

    .mzip:hover {
      background: #00bfa0;
    }

    .step-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 10px;
      font-weight: 800;
      margin-right: 6px;
      flex-shrink: 0;
    }

    .step-row {
      display: flex;
      align-items: flex-start;
      gap: 4px;
      margin-bottom: 8px;
      font-size: 12px;
      color: var(--muted2);
      line-height: 1.6;
    }

    /* toast */
    #toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--accent2);
      color: #000;
      padding: 8px 20px;
      border-radius: 30px;
      font-size: 12px;
      font-weight: 700;
      opacity: 0;
      transition: all .3s;
      pointer-events: none;
      z-index: 9999;
    }

    #toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* SIZE +/- BUTTONS */
    .size-stepper {
      display: flex;
      align-items: center;
      flex: 1;
      gap: 0;
    }

    .size-btn {
      width: 28px;
      height: 28px;
      background: var(--surface3);
      border: 1px solid var(--border2);
      color: var(--text);
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .12s;
      flex-shrink: 0;
      line-height: 1;
    }

    .size-btn:first-child {
      border-radius: 5px 0 0 5px;
    }

    .size-btn:last-child {
      border-radius: 0 5px 5px 0;
    }

    .size-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .size-val {
      flex: 1;
      text-align: center;
      background: var(--surface3);
      border-top: 1px solid var(--border2);
      border-bottom: 1px solid var(--border2);
      border-left: none;
      border-right: none;
      color: var(--text);
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      padding: 4px 0;
      outline: none;
    }

    .size-val:focus {
      background: var(--surface2);
    }

    /* COLOR PALETTE SYSTEM */
    .palette-row {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 6px;
      flex-wrap: wrap;
    }

    .swatch {
      width: 22px;
      height: 22px;
      border-radius: 5px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all .12s;
      flex-shrink: 0;
      position: relative;
      overflow: hidden;
    }

    .swatch:hover {
      transform: scale(1.18);
    }

    .swatch.active-pal {
      border-color: #fff;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, .3);
    }

    .save-pal-btn {
      height: 22px;
      padding: 0 8px;
      background: var(--surface3);
      border: 1px dashed var(--border2);
      color: var(--muted);
      border-radius: 5px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 700;
      font-family: 'Syne', sans-serif;
      white-space: nowrap;
      transition: all .12s;
    }

    .save-pal-btn:hover {
      border-color: var(--accent2);
      color: var(--accent2);
    }

    .apply-all-btn {
      width: 100%;
      background: rgba(0, 212, 170, .1);
      border: 1px solid rgba(0, 212, 170, .25);
      color: var(--accent2);
      padding: 5px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 700;
      font-family: 'Syne', sans-serif;
      margin-top: 4px;
      transition: all .12s;
    }

    .apply-all-btn:hover {
      background: rgba(0, 212, 170, .2);
    }

    .pal-name-inp {
      flex: 1;
      background: var(--surface3);
      border: 1px solid var(--border2);
      border-radius: 5px;
      color: var(--text);
      padding: 3px 7px;
      font-family: 'Syne', sans-serif;
      font-size: 10px;
      outline: none;
    }

    .pal-name-inp:focus {
      border-color: var(--accent2);
    }
  </style>
</head>

<body>
  <div id="toolbar">
    <div class="logo">
      <div class="logo-mark">SC</div>
      <div>
        <div class="logo-text">Plugin Studio</div>
        <div class="logo-sub">by Sound Capsule / Plugin Corp</div>
      </div>
    </div>
    <div class="tb-sep"></div>
    <div id="brand-switcher"></div>
    <div class="tb-sep"></div>
    <button class="tb-btn" onclick="loadProject()">ðŸ“‚ Open</button>
    <button class="tb-btn" onclick="saveProject()">ðŸ’¾ Save</button>
    <button class="tb-btn" id="undo-btn" onclick="undo()" title="Undo (Cmd+Z)" style="opacity:.4;cursor:not-allowed">â†©
      Undo</button>
    <button class="tb-btn" id="redo-btn" onclick="redo()" title="Redo (Cmd+Shift+Z)"
      style="opacity:.4;cursor:not-allowed">â†ª Redo</button>
    <div id="tb-plugin-name"></div>
    <button class="tb-btn primary" onclick="openModal()">âš¡ Export &amp; Build</button>
  </div>

  <div id="main">
    <div id="sidebar">
      <div class="sec">
        <div class="sec-title">Controls</div>
        <div class="add-row">
          <button class="add-btn" onclick="addCtrl('knob')">ï¼‹ Knob</button>
          <button class="add-btn" onclick="addCtrl('slider')">ï¼‹ Slider</button>
        </div>
        <div id="ctrl-list"></div>
      </div>
      <div class="sec">
        <div class="sec-title">Canvas <span id="canvas-lock-badge"></span></div>
        <div class="srow"><span class="slbl">Background</span><input type="color" class="sinp" id="sb-bg"
            oninput="p.bgColor=this.value;drawBg();drawGrid();"></div>
        <div class="srow"><span class="slbl">Grid Color</span><input type="color" class="sinp" id="sb-gc"
            oninput="p.gridColor=this.value;drawGrid();"></div>
        <div class="srow" id="w-row"><span class="slbl">Width</span><input type="number" class="sinp" id="sb-w"
            oninput="if(!p.lockedSize){p.canvasW=+this.value||400;renderCanvas();}"></div>
        <div class="srow" id="h-row"><span class="slbl">Height</span><input type="number" class="sinp" id="sb-h"
            oninput="if(!p.lockedSize){p.canvasH=+this.value||400;renderCanvas();}"></div>
        <div class="srow"><span class="slbl">Grid</span>
          <div class="sseg"><button class="sseg-b" id="gon" onclick="setGrid(true)">On</button>
            <button class="sseg-b" id="goff" onclick="setGrid(false)">Off</button>
          </div>
        </div>
      </div>
      <div class="sec">
        <div class="sec-title">Plugin Info</div>
        <div class="srow"><span class="slbl">Name</span><input type="text" class="sinp" id="sb-pname"
            oninput="p.pluginName=this.value;syncMeta();"></div>
        <div class="srow"><span class="slbl">Company</span><input type="text" class="sinp" id="sb-co"
            oninput="p.companyName=this.value;syncMeta();"></div>
        <div class="srow"><span class="slbl">Co. Code</span><input type="text" class="sinp" id="sb-cc" maxlength="4"
            oninput="p.companyCode=this.value;"></div>
        <div class="srow"><span class="slbl">Plg. Code</span><input type="text" class="sinp" id="sb-pc" maxlength="4"
            oninput="p.pluginCode=this.value;"></div>
        <div class="srow"><span class="slbl">JUCE Dir</span><input type="text" class="sinp" id="sb-juce"
            oninput="p.juceDir=this.value;" style="font-size:10px;"></div>
      </div>
    </div>

    <div id="canvas-area">
      <div id="plugin-canvas">
        <canvas id="cvs-bg"></canvas>
        <canvas id="cvs-grid"></canvas>
        <canvas id="cvs-snap"></canvas>
        <div class="plg-name" id="plg-name"></div>
        <div class="plg-co" id="plg-co"></div>
        <div id="cvs-ctrls"></div>
      </div>
    </div>

    <div id="inspector">
      <div id="insp-content">
        <div id="no-sel">
          <div style="font-size:28px;margin-bottom:10px">ðŸŽ›</div>Select a control on the canvas to edit it.
        </div>
      </div>
    </div>
  </div>

  <!-- EXPORT MODAL -->
  <div id="modal">
    <div class="mbox">
      <div class="mtitle">âš¡ Export Complete VST Package</div>
      <div class="minfo">One zip. Drop it on your Mac, run <code style="color:var(--accent2)">build.sh</code>, your
        <code style="color:var(--accent2)">.vst3</code> appears in <code
          style="color:var(--accent2)">/Library/Audio/Plug-Ins/VST3/</code> and Ableton will see it.
      </div>

      <div>
        <div class="sec-title" style="margin-bottom:8px">WHAT'S INSIDE THE ZIP</div>
        <div id="modal-filelist"></div>
      </div>

      <div>
        <div class="sec-title" style="margin-bottom:8px">3-STEP WORKFLOW</div>
        <div class="step-row"><span class="step-pill">1</span>Click <strong style="color:var(--text)">Download
            .zip</strong> below â€” unzip it to your Desktop</div>
        <div class="step-row"><span class="step-pill">2</span>Open Terminal â†’ <code
            style="color:var(--accent2)">cd</code> into the unzipped folder â†’ run <code
            style="color:var(--accent2)">chmod +x build.sh && ./build.sh</code> â€” script handles everything</div>
        <div class="step-row"><span class="step-pill">3</span>Open Ableton â†’ rescan plugins â†’ <strong
            style="color:var(--text)" id="modal-plgname"></strong> is ready to use</div>
      </div>

      <div>
        <div class="sec-title" style="margin-bottom:6px">BUILD COMMAND (copy-paste alternative)</div>
        <div class="cmd-box" id="modal-cmd" onclick="copyCmd(this)" title="Click to copy">cd ~/<span
            id="modal-dirname"></span>
          cmake -B build -DCMAKE_BUILD_TYPE=Release
          cmake --build build --config Release</div>
        <div style="font-size:10px;color:var(--muted);margin-top:4px">Click the box above to copy Â· requires JUCE +
          CMake installed</div>
      </div>

      <div style="display:flex;gap:10px;justify-content:flex-end;padding-top:4px;">
        <button class="mclose" onclick="closeModal()">Close</button>
        <button class="mzip" onclick="downloadZip()">â¬‡ Download .zip</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  BRANDS  â€” Sound Capsule is always 400Ã—400, Plugin Corp is free
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const BRANDS = {
      'Sound Capsule': {
        color: '#4f8aff',
        pluginName: 'Dreamverb', companyName: 'Sound Capsule', companyCode: 'SdCp', pluginCode: 'DmVb',
        juceDir: '/opt/homebrew/share/JUCE', canvasW: 400, canvasH: 400, lockedSize: true,
        bgColor: '#3a7ca5', gridColor: '#2d6a8f', showGrid: true, gridSize: 20,
        controls: [
          {
            id: 'c1', paramID: 'mix', label: 'MIX', type: 'knob', x: 295, y: 50, size: 180, min: 0, max: 1, def: 0.5,
            knobStyle: 'classic', thumbShape: 'rect', faceColor: '#8ecfc4', ringColor: '#5b8fae', needleColor: '#3a6b5a', labelColor: '#daeef2', fontSize: 11, showLabel: true
          },
          {
            id: 'c2', paramID: 'size', label: 'SIZE', type: 'knob', x: 40, y: 210, size: 140, min: 0, max: 1, def: 0.6,
            knobStyle: 'classic', thumbShape: 'rect', faceColor: '#8ecfc4', ringColor: '#5b8fae', needleColor: '#3a6b5a', labelColor: '#daeef2', fontSize: 11, showLabel: true
          },
          {
            id: 'c3', paramID: 'pre', label: 'PRE', type: 'slider', x: 330, y: 230, size: 120, min: 0, max: 200, def: 20,
            knobStyle: 'classic', thumbShape: 'rect', faceColor: '#7bbfb5', ringColor: '#5b8fae', needleColor: '#3a6b5a', labelColor: '#daeef2', fontSize: 11, showLabel: true
          },
          {
            id: 'c4', paramID: 'damp', label: 'DAMP', type: 'slider', x: 400, y: 230, size: 120, min: 0, max: 1, def: 0.4,
            knobStyle: 'classic', thumbShape: 'rect', faceColor: '#7bbfb5', ringColor: '#5b8fae', needleColor: '#3a6b5a', labelColor: '#daeef2', fontSize: 11, showLabel: true
          },
        ]
      },
      'Plugin Corp': {
        color: '#f0b429',
        pluginName: 'HardComp', companyName: 'Plugin Corp', companyCode: 'PlCp', pluginCode: 'HdCp',
        juceDir: '/opt/homebrew/share/JUCE', canvasW: 700, canvasH: 300, lockedSize: false,
        bgColor: '#0e0e1a', gridColor: '#18182e', showGrid: true, gridSize: 20,
        controls: [
          {
            id: 'd1', paramID: 'threshold', label: 'THRESH', type: 'knob', x: 30, y: 60, size: 140, min: -60, max: 0, def: -12,
            knobStyle: 'metal', thumbShape: 'circle', faceColor: '#1a1a2e', ringColor: '#f0b429', needleColor: '#f0b429', labelColor: '#f0b429', fontSize: 11, showLabel: true
          },
          {
            id: 'd2', paramID: 'ratio', label: 'RATIO', type: 'knob', x: 185, y: 60, size: 140, min: 1, max: 20, def: 4,
            knobStyle: 'metal', thumbShape: 'circle', faceColor: '#1a1a2e', ringColor: '#f0b429', needleColor: '#f0b429', labelColor: '#f0b429', fontSize: 11, showLabel: true
          },
          {
            id: 'd3', paramID: 'attack', label: 'ATK', type: 'knob', x: 340, y: 60, size: 140, min: 0.1, max: 100, def: 10,
            knobStyle: 'metal', thumbShape: 'circle', faceColor: '#1a1a2e', ringColor: '#f0b429', needleColor: '#f0b429', labelColor: '#f0b429', fontSize: 11, showLabel: true
          },
          {
            id: 'd4', paramID: 'release', label: 'REL', type: 'knob', x: 495, y: 60, size: 140, min: 10, max: 1000, def: 100,
            knobStyle: 'metal', thumbShape: 'circle', faceColor: '#1a1a2e', ringColor: '#f0b429', needleColor: '#f0b429', labelColor: '#f0b429', fontSize: 11, showLabel: true
          },
        ]
      }
    };

    const KNOB_STYLES = ['classic', 'metal', 'minimal', 'retro', 'flat', 'skeuomorph', 'neon', 'wood'];

    let currentBrand = 'Sound Capsule';
    let p = clone(BRANDS[currentBrand]);
    let selID = null, drag = null, dragOff = { x: 0, y: 0 }, snapLines = [];

    function clone(o) { return JSON.parse(JSON.stringify(o)); }
    function ctrlW(c) { return c.type === 'knob' ? c.size : 44; }
    function ctrlH(c) { return c.size; }
    function sanitize(s) { return (s || '').replace(/[^a-zA-Z0-9_]/g, ''); }

    // â”€â”€ BOOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function boot() {
      buildBrandSwitcher();
      syncSidebar();
      renderCanvas();
      renderCtrlList();
      renderInspector();
      // keyboard shortcuts
      document.addEventListener('keydown', e => {
        if (e.target.tagName === 'INPUT') return;
        if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); return; }
        if ((e.metaKey || e.ctrlKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); redo(); return; }
        if ((e.key === 'Delete' || e.key === 'Backspace') && selID) { delCtrl(selID); }
        if (e.key === 'Escape') { selCtrl(null); }
        if ((e.key === 'd' || e.key === 'D') && (e.metaKey || e.ctrlKey)) { e.preventDefault(); duplicateSelected(); }
        const mv = { ArrowLeft: [-1, 0], ArrowRight: [1, 0], ArrowUp: [0, -1], ArrowDown: [0, 1] };
        if (mv[e.key] && selID) {
          e.preventDefault();
          const c = p.controls.find(c => c.id === selID); if (!c) return;
          const step = e.shiftKey ? 10 : 1;
          c.x = Math.max(0, c.x + mv[e.key][0] * step);
          c.y = Math.max(0, c.y + mv[e.key][1] * step);
          renderCanvas(); renderInspector();
        }
      });
    }

    function buildBrandSwitcher() {
      const sw = document.getElementById('brand-switcher'); sw.innerHTML = '';
      Object.entries(BRANDS).forEach(([name, brand]) => {
        const btn = document.createElement('button');
        btn.className = 'brand-pill' + (name === currentBrand ? ' active' : '');
        if (name === currentBrand) btn.style.background = brand.color;
        btn.textContent = name; btn.onclick = () => switchBrand(name); sw.appendChild(btn);
      });
    }

    function switchBrand(name) {
      currentBrand = name; p = clone(BRANDS[name]); selID = null;
      // Sync activePalette to the brand's first control
      if (p.controls.length) {
        const fc = p.controls[0];
        activePalette = {
          faceColor: fc.faceColor, ringColor: fc.ringColor,
          needleColor: fc.needleColor, labelColor: fc.labelColor
        };
      }
      syncSidebar(); renderCanvas(); renderCtrlList(); renderInspector(); buildBrandSwitcher();
    }

    function syncSidebar() {
      document.getElementById('sb-bg').value = p.bgColor;
      document.getElementById('sb-gc').value = p.gridColor;
      document.getElementById('sb-w').value = p.canvasW;
      document.getElementById('sb-h').value = p.canvasH;
      document.getElementById('sb-pname').value = p.pluginName;
      document.getElementById('sb-co').value = p.companyName;
      document.getElementById('sb-cc').value = p.companyCode;
      document.getElementById('sb-pc').value = p.pluginCode;
      document.getElementById('sb-juce').value = p.juceDir;
      document.getElementById('gon').classList.toggle('on', p.showGrid);
      document.getElementById('goff').classList.toggle('on', !p.showGrid);
      document.getElementById('tb-plugin-name').textContent = p.pluginName;
      // lock badge & disabled inputs for Sound Capsule 400Ã—400
      const badge = document.getElementById('canvas-lock-badge');
      const wInp = document.getElementById('sb-w');
      const hInp = document.getElementById('sb-h');
      if (p.lockedSize) {
        badge.innerHTML = '<span class="locked-badge">400Ã—400 locked</span>';
        wInp.disabled = true; hInp.disabled = true;
        wInp.style.opacity = '.4'; hInp.style.opacity = '.4';
      } else {
        badge.innerHTML = '';
        wInp.disabled = false; hInp.disabled = false;
        wInp.style.opacity = '1'; hInp.style.opacity = '1';
      }
    }

    function syncMeta() {
      document.getElementById('tb-plugin-name').textContent = p.pluginName;
      document.getElementById('plg-name').textContent = p.pluginName.toUpperCase();
      document.getElementById('plg-co').textContent = p.companyName.toUpperCase();
    }

    // â”€â”€ CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderCanvas() {
      const el = document.getElementById('plugin-canvas');
      el.style.width = p.canvasW + 'px'; el.style.height = p.canvasH + 'px';
      drawBg(); drawGrid(); drawSnap(); renderCtrls();
      document.getElementById('plg-name').textContent = p.pluginName.toUpperCase();
      document.getElementById('plg-co').textContent = p.companyName.toUpperCase();
      document.getElementById('tb-plugin-name').textContent = p.pluginName;
    }

    function getCtx(id) {
      const c = document.getElementById(id); c.width = p.canvasW; c.height = p.canvasH; return c.getContext('2d');
    }

    function drawBg() {
      const ctx = getCtx('cvs-bg');
      ctx.fillStyle = p.bgColor; ctx.fillRect(0, 0, p.canvasW, p.canvasH);
      const g = ctx.createRadialGradient(p.canvasW / 2, p.canvasH / 2, 0, p.canvasW / 2, p.canvasH / 2, Math.max(p.canvasW, p.canvasH) * .75);
      g.addColorStop(0, 'rgba(0,0,0,0)'); g.addColorStop(1, 'rgba(0,0,0,0.32)');
      ctx.fillStyle = g; ctx.fillRect(0, 0, p.canvasW, p.canvasH);
    }

    function drawGrid() {
      const ctx = getCtx('cvs-grid');
      if (!p.showGrid) return;
      ctx.strokeStyle = hexA(p.gridColor, .45); ctx.lineWidth = .5;
      for (let x = 0; x < p.canvasW; x += p.gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, p.canvasH); ctx.stroke(); }
      for (let y = 0; y < p.canvasH; y += p.gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(p.canvasW, y); ctx.stroke(); }
    }

    function drawSnap() {
      const ctx = getCtx('cvs-snap');
      if (!snapLines.length) { ctx.clearRect(0, 0, p.canvasW, p.canvasH); return; }
      ctx.strokeStyle = 'rgba(80,200,255,.8)'; ctx.lineWidth = 1; ctx.setLineDash([4, 3]);
      snapLines.forEach(l => {
        ctx.beginPath();
        if (l.axis === 'x') { ctx.moveTo(l.pos, 0); ctx.lineTo(l.pos, p.canvasH); }
        else { ctx.moveTo(0, l.pos); ctx.lineTo(p.canvasW, l.pos); }
        ctx.stroke();
      });
      ctx.setLineDash([]);
    }

    // â”€â”€ SVG HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function mkEl(tag, attrs) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v)); return el;
    }
    function arc(cx, cy, r, a1, a2) {
      const x1 = cx + Math.sin(a1) * r, y1 = cy - Math.cos(a1) * r, x2 = cx + Math.sin(a2) * r, y2 = cy - Math.cos(a2) * r;
      return `M${x1},${y1} A${r},${r},0,${a2 - a1 > Math.PI ? 1 : 0},1,${x2},${y2}`;
    }
    function lighten(hex, n) {
      let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
      return '#' + [Math.min(255, r + n), Math.min(255, g + n), Math.min(255, b + n)].map(v => v.toString(16).padStart(2, '0')).join('');
    }
    function darken(hex, n) {
      let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
      return '#' + [Math.max(0, r - n), Math.max(0, g - n), Math.max(0, b - n)].map(v => v.toString(16).padStart(2, '0')).join('');
    }
    function hexA(hex, a) {
      const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    // â”€â”€ KNOB STYLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function buildKnob(svg, c, val = 0.4) {
      const s = c.size, cx = s / 2, cy = s / 2;
      const outerR = s * .48, innerR = outerR * .78;
      const angle = -2.356 + val * 4.712;
      const sinA = Math.sin(angle), cosA = Math.cos(angle);
      svg.setAttribute('width', s); svg.setAttribute('height', s);
      const st = c.knobStyle || 'classic';

      if (st === 'classic') {
        const bg = c.bgColor || 'transparent';
        if (bg !== 'transparent') svg.appendChild(mkEl('circle', { cx, cy, r: outerR * 1.05, fill: bg }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: c.ringColor }));
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: c.faceColor }));
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .91, -2.356, 2.356), stroke: hexA(c.trackFillColor || c.ringColor, .4), fill: 'none', 'stroke-width': outerR * .11, 'stroke-linecap': 'round' }));
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .91, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': outerR * .11, 'stroke-linecap': 'round' }));
        needle(svg, cx, cy, innerR, sinA, cosA, c.needleColor, s * .013);
      } else if (st === 'metal') {
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gr = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
        gr.id = 'mg' + c.id; gr.setAttribute('cx', '35%'); gr.setAttribute('cy', '35%');
        [[0, lighten(c.faceColor, 35)], [100, darken(c.faceColor, 15)]].forEach(([o, col]) => {
          gr.appendChild(mkEl('stop', { 'offset': o + '%', 'stop-color': col }));
        });
        defs.appendChild(gr); svg.appendChild(defs);
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: 'none', stroke: c.ringColor, 'stroke-width': outerR * .16, opacity: .9 }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR * .85, fill: `url(#mg${c.id})` }));
        for (let i = 0; i <= 10; i++) {
          const ta = -2.356 + i * (4.712 / 10);
          const r1 = outerR * .72, r2 = i % 5 === 0 ? outerR * .6 : outerR * .67;
          svg.appendChild(mkEl('line', { x1: cx + Math.sin(ta) * r1, y1: cy - Math.cos(ta) * r1, x2: cx + Math.sin(ta) * r2, y2: cy - Math.cos(ta) * r2, stroke: c.ringColor, 'stroke-width': i % 5 === 0 ? 1.5 : .7, opacity: .7 }));
        }
        needle(svg, cx, cy, outerR * .58, sinA, cosA, c.needleColor, 2.5);
      } else if (st === 'minimal') {
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: c.faceColor }));
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .78, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': s * .022, 'stroke-linecap': 'round' }));
        svg.appendChild(mkEl('circle', { cx: cx + sinA * outerR * .88, cy: cy - cosA * outerR * .88, r: s * .04, fill: c.needleColor }));
      } else if (st === 'retro') {
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: c.ringColor }));
        for (let i = 0; i <= 24; i++) {
          const ta = -2.8 + i * (5.6 / 24);
          svg.appendChild(mkEl('line', { x1: cx + Math.sin(ta) * outerR, y1: cy - Math.cos(ta) * outerR, x2: cx + Math.sin(ta) * (outerR * .87), y2: cy - Math.cos(ta) * (outerR * .87), stroke: darken(c.ringColor, 25), 'stroke-width': 1.2 }));
        }
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: c.faceColor }));
        const pr = innerR * .68, pw = s * .055;
        const tx = cx + sinA * pr, ty = cy - cosA * pr;
        const l1x = cx - sinA * innerR * .15 - cosA * pw, l1y = cy + cosA * innerR * .15 - sinA * pw;
        const l2x = cx - sinA * innerR * .15 + cosA * pw, l2y = cy + cosA * innerR * .15 + sinA * pw;
        svg.appendChild(mkEl('polygon', { points: `${tx},${ty} ${l1x},${l1y} ${l2x},${l2y}`, fill: c.needleColor }));
      } else if (st === 'flat') {
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: c.faceColor }));
        const hw = s * .038;
        const tx = cx + sinA * innerR * .76, ty = cy - cosA * innerR * .76;
        const bx = cx - sinA * innerR * .18, by = cy + cosA * innerR * .18;
        svg.appendChild(mkEl('polygon', { points: `${tx},${ty} ${bx - cosA * hw},${by - sinA * hw} ${bx + cosA * hw},${by + sinA * hw}`, fill: c.needleColor }));
      } else if (st === 'skeuomorph') {
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gr = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
        gr.id = 'sk' + c.id; gr.setAttribute('cx', '30%'); gr.setAttribute('cy', '25%');
        [[0, lighten(c.ringColor, 50)], [40, c.ringColor], [100, darken(c.ringColor, 40)]].forEach(([o, col]) => {
          gr.appendChild(mkEl('stop', { 'offset': o + '%', 'stop-color': col }));
        });
        defs.appendChild(gr); svg.appendChild(defs);
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: `url(#sk${c.id})` }));
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR * 1.04, fill: 'rgba(0,0,0,.28)' }));
        const defs2 = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gr2 = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
        gr2.id = 'skf' + c.id; gr2.setAttribute('cx', '35%'); gr2.setAttribute('cy', '30%');
        [[0, lighten(c.faceColor, 28)], [100, darken(c.faceColor, 8)]].forEach(([o, col]) => {
          gr2.appendChild(mkEl('stop', { 'offset': o + '%', 'stop-color': col }));
        });
        defs2.appendChild(gr2); svg.appendChild(defs2);
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: `url(#skf${c.id})` }));
        needle(svg, cx, cy, innerR, sinA, cosA, c.needleColor, s * .015);
        svg.appendChild(mkEl('circle', { cx, cy, r: s * .055, fill: c.dotColor || darken(c.faceColor, 18) }));
      } else if (st === 'neon') {
        const bg = c.bgColor || 'rgba(0,0,0,.65)';
        const hl = c.highlightColor || c.needleColor;
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: c.faceColor }));
        // Outer glow ring (uses trackFillColor as glow background)
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .88, -2.356, 2.356), stroke: hexA(c.trackFillColor || c.needleColor, .25), fill: 'none', 'stroke-width': outerR * .1, 'stroke-linecap': 'round' }));
        // Active neon arc (double line for glow effect)
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .88, -2.356, angle), stroke: hexA(hl, .3), fill: 'none', 'stroke-width': outerR * .14, 'stroke-linecap': 'round' }));
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .88, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': outerR * .05, 'stroke-linecap': 'round' }));
        needle(svg, cx, cy, innerR, sinA, cosA, c.needleColor, 2.5);
      } else if (st === 'neon2') {
        // Neon single color â€” clean single arc, no double line
        const bg = c.bgColor || 'rgba(0,0,0,.65)';
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: c.faceColor }));
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .88, -2.356, 2.356), stroke: hexA(c.trackFillColor || c.needleColor, .2), fill: 'none', 'stroke-width': outerR * .1, 'stroke-linecap': 'round' }));
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .88, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': outerR * .1, 'stroke-linecap': 'round' }));
        needle(svg, cx, cy, innerR, sinA, cosA, c.needleColor, 2.5);

      } else if (st === 'wood') {
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gr = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
        gr.id = 'wd' + c.id; gr.setAttribute('x1', '0%'); gr.setAttribute('y1', '0%'); gr.setAttribute('x2', '100%'); gr.setAttribute('y2', '100%');
        [['0%', '#7c5c3a'], ['38%', '#a07444'], ['62%', '#8a6238'], ['100%', '#5a3e22']].forEach(([o, col]) => {
          gr.appendChild(mkEl('stop', { offset: o, 'stop-color': col }));
        });
        defs.appendChild(gr); svg.appendChild(defs);
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: `url(#wd${c.id})` }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: 'none', stroke: 'rgba(0,0,0,.25)', 'stroke-width': 1 }));
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: c.faceColor }));
        svg.appendChild(mkEl('circle', { cx, cy, r: s * .055, fill: c.dotColor || '#2a1a08' }));
        needle(svg, cx, cy, innerR, sinA, cosA, c.needleColor || '#f0d090', 3);

      } else if (st === 'vu') {
        // VU meter style â€” rectangular body with arc indicator
        const bg = c.bgColor || '#0a0a0a';
        const hl = c.highlightColor || '#ffffff';
        svg.appendChild(mkEl('rect', { x: 0, y: 0, width: s, height: s, rx: s * .06, fill: bg }));
        svg.appendChild(mkEl('rect', { x: 0, y: 0, width: s, height: s, rx: s * .06, fill: 'none', stroke: c.ringColor, 'stroke-width': s * .025 }));
        // Tick marks around arc
        for (let i = 0; i <= 12; i++) {
          const ta = -2.1 + i * (4.2 / 12);
          const isMain = i % 3 === 0;
          const r1 = outerR * .92, r2 = isMain ? outerR * .72 : outerR * .8;
          const col = i >= 10 ? '#ff4444' : i >= 8 ? '#ffaa00' : c.ringColor;
          svg.appendChild(mkEl('line', { x1: cx + Math.sin(ta) * r1, y1: cy - Math.cos(ta) * r1, x2: cx + Math.sin(ta) * r2, y2: cy - Math.cos(ta) * r2, stroke: col, 'stroke-width': isMain ? 2 : 1 }));
        }
        // Active arc sweep
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .62, -2.1, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': outerR * .14, 'stroke-linecap': 'round', opacity: .9 }));
        // VU needle line
        svg.appendChild(mkEl('line', { x1: cx, y1: cy, x2: cx + sinA * outerR * .7, y2: cy - cosA * outerR * .7, stroke: c.needleColor, 'stroke-width': 2, 'stroke-linecap': 'round' }));
        // "VU" text label
        svg.appendChild(mkEl('text', { x: cx, y: s * .88, 'text-anchor': 'middle', 'font-size': s * .1, 'font-family': 'monospace', fill: hexA(hl, .4) }));

      } else if (st === 'aerospace') {
        // Precision instrument look â€” dark with etched rings and data display
        const bg = c.bgColor || '#050810';
        const hl = c.highlightColor || '#00ccff';
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: 'none', stroke: hexA(hl, .15), 'stroke-width': 2 }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR * .82, fill: 'none', stroke: hexA(hl, .08), 'stroke-width': 1 }));
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: c.faceColor }));
        // Outer ring with gradient glow effect
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR * .95, fill: 'none', stroke: c.ringColor, 'stroke-width': outerR * .06, opacity: .8 }));
        // Fine tick marks
        for (let i = 0; i <= 30; i++) {
          const ta = -2.356 + i * (4.712 / 30);
          const isMain = i % 5 === 0;
          const r1 = innerR * 1.08, r2 = isMain ? innerR * .88 : innerR * .96;
          svg.appendChild(mkEl('line', { x1: cx + Math.sin(ta) * r1, y1: cy - Math.cos(ta) * r1, x2: cx + Math.sin(ta) * r2, y2: cy - Math.cos(ta) * r2, stroke: hl, 'stroke-width': isMain ? 1.5 : .5, opacity: isMain ? .7 : .3 }));
        }
        // Active arc
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .76, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': outerR * .065, 'stroke-linecap': 'round' }));
        // Center crosshair dot

        needle(svg, cx, cy, innerR * .8, sinA, cosA, c.needleColor, s * .012);

      } else if (st === 'pill') {
        // Soft rounded pill shape â€” playful and modern
        const bg = c.bgColor || '#1a0a2e';
        const hl = c.highlightColor || '#ffffff';
        const pw = s * .7, ph = s * .85;
        const px = (s - pw) / 2, py = (s - ph) / 2;
        svg.appendChild(mkEl('rect', { x: px, y: py, width: pw, height: ph, rx: pw / 2, fill: bg }));
        svg.appendChild(mkEl('rect', { x: px, y: py, width: pw, height: ph, rx: pw / 2, fill: 'none', stroke: c.ringColor, 'stroke-width': s * .028 }));
        // Inner pill face
        const iw = pw * .78, ih = ph * .78;
        const ix = (s - iw) / 2, iy = (s - ih) / 2;
        svg.appendChild(mkEl('rect', { x: ix, y: iy, width: iw, height: ih, rx: iw / 2, fill: c.faceColor }));
        // Top highlight sheen
        svg.appendChild(mkEl('rect', { x: ix + iw * .1, y: iy + ih * .06, width: iw * .8, height: ih * .22, rx: iw * .35, fill: hl, opacity: .18 }));
        // Active arc on the ring
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .94, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': s * .035, 'stroke-linecap': 'round' }));
        // Indicator dot
        const dx = cx + sinA * outerR * .62, dy = cy - cosA * outerR * .62;
        svg.appendChild(mkEl('circle', { cx: dx, cy: dy, r: s * .06, fill: c.needleColor }));
        svg.appendChild(mkEl('circle', { cx: dx, cy: dy, r: s * .03, fill: hl, opacity: .5 }));

      } else if (st === 'bubblegum') {
        // Fun, colorful, candy aesthetic
        const bg = c.bgColor || '#ff69b4';
        const hl = c.highlightColor || '#ffffff';
        // Outer gloss circle
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gr = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
        gr.id = 'bg' + c.id; gr.setAttribute('cx', '38%'); gr.setAttribute('cy', '32%');
        [[0, lighten(c.ringColor, 50)], [45, c.ringColor], [100, darken(c.ringColor, 25)]].forEach(([o, col]) => {
          gr.appendChild(mkEl('stop', { 'offset': o + '%', 'stop-color': col }));
        });
        defs.appendChild(gr); svg.appendChild(defs);
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: `url(#bg${c.id})` }));
        // Specular highlight blob
        svg.appendChild(mkEl('ellipse', { cx: cx - outerR * .22, cy: cy - outerR * .25, rx: outerR * .32, ry: outerR * .2, fill: hl, opacity: .35 }));
        // Inner bubble
        const defs2 = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const gr2 = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
        gr2.id = 'bgf' + c.id; gr2.setAttribute('cx', '40%'); gr2.setAttribute('cy', '35%');
        [[0, lighten(c.faceColor, 40)], [100, c.faceColor]].forEach(([o, col]) => {
          gr2.appendChild(mkEl('stop', { 'offset': o + '%', 'stop-color': col }));
        });
        defs2.appendChild(gr2); svg.appendChild(defs2);
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: `url(#bgf${c.id})` }));
        svg.appendChild(mkEl('ellipse', { cx: cx - innerR * .2, cy: cy - innerR * .22, rx: innerR * .28, ry: innerR * .16, fill: hl, opacity: .3 }));
        // Needle dot
        svg.appendChild(mkEl('circle', { cx: cx + sinA * innerR * .7, cy: cy - cosA * innerR * .7, r: s * .065, fill: c.needleColor }));
        svg.appendChild(mkEl('circle', { cx: cx + sinA * innerR * .7 - s * .02, cy: cy - cosA * innerR * .7 - s * .02, r: s * .025, fill: hl, opacity: .6 }));
        // Center dot

      } else if (st === 'wire') {
        // Minimal wireframe look â€” just outlines, no fills
        const bg = c.bgColor || 'transparent';
        const hl = c.highlightColor || c.needleColor;
        if (bg !== 'transparent') svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        // Outer ring outline only
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: 'none', stroke: c.ringColor, 'stroke-width': 1.5 }));
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR, fill: 'none', stroke: c.faceColor, 'stroke-width': 1 }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR * .6, fill: 'none', stroke: hexA(c.faceColor, .4), 'stroke-width': .75 }));
        // Track arc (empty)
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .85, -2.356, 2.356), stroke: hexA(c.ringColor, .3), fill: 'none', 'stroke-width': 1, 'stroke-linecap': 'round' }));
        // Active arc (filled line)
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .85, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': 2, 'stroke-linecap': 'round' }));
        // Cross hair center
        svg.appendChild(mkEl('line', { x1: cx - s * .07, y1: cy, x2: cx + s * .07, y2: cy, stroke: hexA(c.faceColor, .5), 'stroke-width': .8 }));
        svg.appendChild(mkEl('line', { x1: cx, y1: cy - s * .07, x2: cx, y2: cy + s * .07, stroke: hexA(c.faceColor, .5), 'stroke-width': .8 }));

        // Needle as a wire line
        svg.appendChild(mkEl('line', { x1: cx, y1: cy, x2: cx + sinA * outerR * .75, y2: cy - cosA * outerR * .75, stroke: hl, 'stroke-width': 1.5, 'stroke-linecap': 'round' }));
      } else if (st === 'clock') {
        // Clock face â€” hour markers around edge, single hand pointer
        const bg = c.bgColor || '#0d0d0d';
        const hl = c.highlightColor || '#ffffff';
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: 'none', stroke: c.ringColor, 'stroke-width': s * .018 }));
        // 12 hour markers
        for (let i = 0; i < 12; i++) {
          const ta = (i / 12) * Math.PI * 2 - Math.PI / 2;
          const isMain = i % 3 === 0;
          const r1 = outerR * .92, r2 = isMain ? outerR * .72 : outerR * .82;
          svg.appendChild(mkEl('line', {
            x1: cx + Math.cos(ta) * r1, y1: cy + Math.sin(ta) * r1,
            x2: cx + Math.cos(ta) * r2, y2: cy + Math.sin(ta) * r2,
            stroke: isMain ? hl : hexA(hl, .4), 'stroke-width': isMain ? 2 : 1, 'stroke-linecap': 'round'
          }));
        }
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR * .7, fill: c.faceColor }));
        // Clock hand
        svg.appendChild(mkEl('line', {
          x1: cx - sinA * innerR * .18, y1: cy + cosA * innerR * .18,
          x2: cx + sinA * innerR * .62, y2: cy - cosA * innerR * .62,
          stroke: c.needleColor, 'stroke-width': s * .022, 'stroke-linecap': 'round'
        }));
        // Short counter hand
        svg.appendChild(mkEl('line', {
          x1: cx, y1: cy, x2: cx - sinA * innerR * .22, y2: cy + cosA * innerR * .22,
          stroke: c.needleColor, 'stroke-width': s * .014, 'stroke-linecap': 'round'
        }));

      } else if (st === 'diamond') {
        // Diamond / gem cut â€” polygon facets radiating out
        const bg = c.bgColor || '#0a0a14';
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        // Outer gem ring
        const pts = 8;
        const outerPts = [], innerPts = [];
        for (let i = 0; i < pts; i++) {
          const a = (i / pts) * Math.PI * 2 - Math.PI / 2;
          const a2 = ((i + .5) / pts) * Math.PI * 2 - Math.PI / 2;
          outerPts.push(`${cx + Math.cos(a) * outerR * .92},${cy + Math.sin(a) * outerR * .92}`);
          innerPts.push(`${cx + Math.cos(a2) * outerR * .72},${cy + Math.sin(a2) * outerR * .72}`);
        }
        // Alternating facets
        for (let i = 0; i < pts; i++) {
          const [ox1, oy1] = outerPts[i].split(',');
          const [ox2, oy2] = outerPts[(i + 1) % pts].split(',');
          const [ix, iy] = innerPts[i].split(',');
          svg.appendChild(mkEl('polygon', {
            points: `${ox1},${oy1} ${ix},${iy} ${ox2},${oy2}`,
            fill: i % 2 === 0 ? hexA(c.ringColor, .8) : hexA(lighten(c.ringColor, 25), .5), stroke: bg, 'stroke-width': .5
          }));
        }
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR * .62, fill: c.faceColor }));
        // Active arc
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .55, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': s * .025, 'stroke-linecap': 'round' }));
        needle(svg, cx, cy, outerR * .48, sinA, cosA, c.needleColor, s * .014);

      } else if (st === 'tape') {
        // Cassette tape reel aesthetic â€” spokes and hub
        const bg = c.bgColor || '#1a1008';
        const hl = c.highlightColor || '#f0c060';
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: 'none', stroke: c.ringColor, 'stroke-width': s * .03 }));
        // Tape reel spokes (5 spokes)
        for (let i = 0; i < 5; i++) {
          const a = (i / 5) * Math.PI * 2;
          svg.appendChild(mkEl('rect', {
            x: cx - s * .035, y: cy - outerR * .72,
            width: s * .07, height: outerR * .44,
            rx: s * .018, fill: c.faceColor,
            transform: `rotate(${(i / 5) * 360},${cx},${cy})`
          }));
        }
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR * .3, fill: darken(bg, 5), stroke: c.ringColor, 'stroke-width': 1.5 }));
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR * .16, fill: bg, stroke: hexA(hl, .5), 'stroke-width': 1 }));
        // Active arc on outside
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .96, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': s * .03, 'stroke-linecap': 'round' }));

      } else if (st === 'radar') {
        // Radar sweep â€” concentric rings with sweep line
        const bg = c.bgColor || '#001a0d';
        const hl = c.highlightColor || '#00ff88';
        svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        // Concentric rings
        [.85, .65, .45, .25].forEach(r => {
          svg.appendChild(mkEl('circle', { cx, cy, r: outerR * r, fill: 'none', stroke: hexA(c.ringColor, .25), 'stroke-width': .8 }));
        });
        // Cross hairs
        svg.appendChild(mkEl('line', { x1: cx - outerR, y1: cy, x2: cx + outerR, y2: cy, stroke: hexA(c.ringColor, .2), 'stroke-width': .8 }));
        svg.appendChild(mkEl('line', { x1: cx, y1: cy - outerR, x2: cx, y2: cy + outerR, stroke: hexA(c.ringColor, .2), 'stroke-width': .8 }));
        // Sweep trail (fading arc behind needle)
        const trailEnd = angle, trailStart = angle - 1.2;
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .78, trailStart, trailEnd), stroke: hexA(hl, .15), fill: 'none', 'stroke-width': outerR * .18, 'stroke-linecap': 'butt' }));
        // Sweep line
        svg.appendChild(mkEl('line', { x1: cx, y1: cy, x2: cx + sinA * outerR * .88, y2: cy - cosA * outerR * .88, stroke: c.needleColor, 'stroke-width': 1.5, 'stroke-linecap': 'round' }));
        svg.appendChild(mkEl('circle', { cx, cy, r: s * .03, fill: c.needleColor }));
        // Blip at needle tip
        svg.appendChild(mkEl('circle', { cx: cx + sinA * outerR * .78, cy: cy - cosA * outerR * .78, r: s * .04, fill: hl, opacity: .9 }));

      } else if (st === 'hex') {
        // Hexagonal industrial â€” flat hex shape with segment indicators
        const bg = c.bgColor || '#0c0c10';
        const hl = c.highlightColor || '#ffffff';
        // Draw hexagon
        const hexPts = [...Array(6)].map((_, i) => {
          const a = (i / 6) * Math.PI * 2 - Math.PI / 6;
          return `${cx + Math.cos(a) * outerR * .95},${cy + Math.sin(a) * outerR * .95}`;
        }).join(' ');
        svg.appendChild(mkEl('polygon', { points: hexPts, fill: bg, stroke: c.ringColor, 'stroke-width': s * .025 }));
        // Inner hex face
        const hexInner = [...Array(6)].map((_, i) => {
          const a = (i / 6) * Math.PI * 2 - Math.PI / 6;
          return `${cx + Math.cos(a) * innerR * .92},${cy + Math.sin(a) * innerR * .92}`;
        }).join(' ');
        svg.appendChild(mkEl('polygon', { points: hexInner, fill: c.faceColor, stroke: 'none' }));
        // Segment dots around the hex
        for (let i = 0; i <= 12; i++) {
          const ta = -2.356 + (i / 12) * 4.712;
          const active = ta <= angle;
          svg.appendChild(mkEl('circle', {
            cx: cx + Math.sin(ta) * outerR * .78, cy: cy - Math.cos(ta) * outerR * .78,
            r: s * .025, fill: active ? c.needleColor : hexA(hl, .15)
          }));
        }
        needle(svg, cx, cy, innerR * .8, sinA, cosA, c.needleColor, s * .016);

      } else if (st === 'ring') {
        // Stacked rings â€” multiple concentric colored rings, no fill
        const bg = c.bgColor || 'transparent';
        const hl = c.highlightColor || '#ffffff';
        if (bg !== 'transparent') svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        // 3 stacked arcs at different radii
        const rings = [
          { r: .92, sw: .055, col: c.ringColor, start: -2.356, end: 2.356, op: .25 },
          { r: .92, sw: .055, col: c.needleColor, start: -2.356, end: angle, op: 1 },
          { r: .72, sw: .04, col: lighten(c.ringColor, 20), start: -2.356, end: 2.356, op: .15 },
          { r: .72, sw: .04, col: c.needleColor, start: -2.356, end: angle * .7 + angle * .3, op: .6 },
          { r: .52, sw: .03, col: c.faceColor, start: -2.356, end: 2.356, op: .2 },
          { r: .52, sw: .03, col: c.needleColor, start: -2.356, end: angle * .4 + angle * .6, op: .35 },
        ];
        rings.forEach(({ r, sw, col, start, end, op }) => {
          svg.appendChild(mkEl('path', {
            d: arc(cx, cy, outerR * r, start, end), stroke: col, fill: 'none',
            'stroke-width': outerR * sw, 'stroke-linecap': 'round', opacity: op
          }));
        });
        // Center indicator dot only (no needle)
        svg.appendChild(mkEl('circle', { cx: cx + sinA * outerR * .3, cy: cy - cosA * outerR * .3, r: s * .04, fill: c.needleColor }));

      } else if (st === 'bar') {
        // LED bar graph style â€” vertical segments like a level meter
        const bg = c.bgColor || '#0a0a0a';
        const hl = c.highlightColor || '#ffffff';
        const segCount = 12;
        const segH = (s * .82) / segCount, segW = s * .55, segGap = s * .018;
        const startY = s * .09;
        const activeCount = Math.round(val * segCount);
        svg.appendChild(mkEl('rect', { x: 0, y: 0, width: s, height: s, rx: s * .06, fill: bg }));
        svg.appendChild(mkEl('rect', { x: 0, y: 0, width: s, height: s, rx: s * .06, fill: 'none', stroke: c.ringColor, 'stroke-width': s * .02 }));
        for (let i = 0; i < segCount; i++) {
          const idx2 = segCount - 1 - i; // top to bottom, top = high value
          const isActive = i >= segCount - activeCount;
          const y = startY + i * (segH);
          const col = idx2 >= segCount * .75 ? '#ff3333' : idx2 >= segCount * .5 ? '#ffaa00' : c.needleColor;
          svg.appendChild(mkEl('rect', {
            x: (s - segW) / 2, y: y, width: segW, height: segH - segGap, rx: s * .018,
            fill: isActive ? col : hexA(hl, .07)
          }));
        }
        // Label on side
        svg.appendChild(mkEl('rect', { x: (s - segW) / 2 - 1, y: startY, width: 1, height: s * .82, fill: hexA(c.ringColor, .3) }));

      } else if (st === 'halo') {
        // Floating halo â€” thick outer glow ring, minimal center
        const bg = c.bgColor || 'transparent';
        const hl = c.highlightColor || c.needleColor;
        if (bg !== 'transparent') svg.appendChild(mkEl('circle', { cx, cy, r: outerR, fill: bg }));
        // Soft background glow behind active arc
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .88, -2.356, angle), stroke: hexA(hl, .12), fill: 'none', 'stroke-width': outerR * .38, 'stroke-linecap': 'round' }));
        // Track
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .88, -2.356, 2.356), stroke: hexA(c.ringColor, .2), fill: 'none', 'stroke-width': outerR * .1, 'stroke-linecap': 'round' }));
        // Halo active arc â€” thick and glowing
        svg.appendChild(mkEl('path', { d: arc(cx, cy, outerR * .88, -2.356, angle), stroke: c.needleColor, fill: 'none', 'stroke-width': outerR * .1, 'stroke-linecap': 'round' }));
        // Tiny indicator circle at tip of arc
        svg.appendChild(mkEl('circle', { cx: cx + sinA * outerR * .88, cy: cy - cosA * outerR * .88, r: s * .055, fill: c.needleColor }));
        // Minimal center face â€” just a small circle
        svg.appendChild(mkEl('circle', { cx, cy, r: innerR * .38, fill: c.faceColor }));
      }
    }

    function needle(svg, cx, cy, innerR, sinA, cosA, color, sw) {
      svg.appendChild(mkEl('line', {
        x1: cx - sinA * innerR * .18, y1: cy + cosA * innerR * .18,
        x2: cx + sinA * innerR * .72, y2: cy - cosA * innerR * .72,
        stroke: color, 'stroke-width': Math.max(2, sw), 'stroke-linecap': 'round'
      }));
    }

    function buildSlider(svg, c) {
      const w = 44, h = c.size; svg.setAttribute('width', w); svg.setAttribute('height', h);
      const cx = w / 2, trackW = 7, thumbY = h * .38, shape = c.thumbShape || 'rect';
      const tw = 32, th = 18;
      const bgCol = c.bgColor || '#111111';
      const trackFill = c.trackFillColor || c.faceColor;
      const highlight = c.highlightColor || '#ffffff';
      // Background rect behind slider
      svg.appendChild(mkEl('rect', { x: 0, y: 0, width: w, height: h, rx: 4, fill: bgCol }));
      // Track groove
      svg.appendChild(mkEl('rect', { x: cx - trackW / 2, y: 0, width: trackW, height: h, rx: trackW / 2, fill: trackFill }));
      // Active fill below thumb (uses ringColor)
      svg.appendChild(mkEl('rect', { x: cx - trackW / 2, y: thumbY, width: trackW, height: h - thumbY, rx: trackW / 2, fill: c.ringColor, opacity: .6 }));

      if (shape === 'circle') {
        svg.appendChild(mkEl('circle', { cx, cy: thumbY, r: tw / 2, fill: c.needleColor }));
        svg.appendChild(mkEl('circle', { cx, cy: thumbY, r: tw / 2 * .55, fill: 'none', stroke: highlight, 'stroke-width': 1.5, opacity: .35 }));
      } else if (shape === 'square') {
        const sq = th + 2;
        svg.appendChild(mkEl('rect', { x: cx - sq / 2, y: thumbY - sq / 2, width: sq, height: sq, rx: 3, fill: c.needleColor }));
        if (c.thumbLine) svg.appendChild(mkEl('line', { x1: cx - sq * .3, y1: thumbY, x2: cx + sq * .3, y2: thumbY, stroke: c.thumbLineColor || highlight, 'stroke-width': 1.5, opacity: (c.thumbLineColor ? 1.0 : 0.4) }));
      } else {
        // rect
        svg.appendChild(mkEl('rect', { x: cx - tw / 2, y: thumbY - th / 2, width: tw, height: th, rx: 5, fill: c.needleColor }));
        // Highlight stripe on thumb
        if (c.thumbLine === 'dots' || c.thumbLine === true || !c.thumbLine) {
          svg.appendChild(mkEl('rect', { x: cx - tw / 2 + 3, y: thumbY - th / 2 + 3, width: tw - 6, height: 3, rx: 1.5, fill: highlight, opacity: .25 }));
        }

        if (c.thumbLine === 'line') {
          const lineCol = c.thumbLineColor || '#ffffff';
          svg.appendChild(mkEl('line', { x1: cx - tw / 2 + 2, y1: thumbY, x2: cx + tw / 2 - 2, y2: thumbY, stroke: lineCol, 'stroke-width': 2.5, 'stroke-linecap': 'round' }));
        } else if (c.thumbLine === 'dots' || c.thumbLine === true) {
          [-3, 0, 3].forEach(dy => {
            svg.appendChild(mkEl('circle', { cx, cy: thumbY + dy, r: 1.5, fill: c.dotColor || highlight, opacity: .55 }));
          });
        }
      }
    }

    // â”€â”€ RENDER CONTROLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderCtrls() {
      const con = document.getElementById('cvs-ctrls'); con.innerHTML = '';
      p.controls.forEach(c => {
        const el = document.createElement('div');
        el.className = 'cc' + (selID === c.id ? ' sel' : '');
        el.dataset.id = c.id;
        el.style.left = c.x + 'px'; el.style.top = c.y + 'px'; el.style.width = ctrlW(c) + 'px';
        el.appendChild(Object.assign(document.createElement('div'), { className: 'sel-ring' }));
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        if (c.type === 'knob') buildKnob(svg, c); else buildSlider(svg, c);
        el.appendChild(svg);
        if (c.showLabel) {
          const lb = document.createElement('div');
          lb.className = 'lbl-txt'; lb.style.color = c.labelColor; lb.style.fontSize = c.fontSize + 'px';
          lb.textContent = c.label.toUpperCase(); el.appendChild(lb);
        }
        el.addEventListener('mousedown', e => {
          e.preventDefault(); e.stopPropagation(); selCtrl(c.id); drag = c.id;
          const cr = document.getElementById('plugin-canvas').getBoundingClientRect();
          dragOff.x = (e.clientX - cr.left) - c.x; dragOff.y = (e.clientY - cr.top) - c.y;
        });
        el.addEventListener('click', e => { e.stopPropagation(); selCtrl(c.id); });
        con.appendChild(el);
      });
    }

    // â”€â”€ SNAPPING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function snapPos(c, rx, ry) {
      const GRID = 10, ALIGN = 9;
      let x = Math.round(rx / GRID) * GRID, y = Math.round(ry / GRID) * GRID;
      const w = ctrlW(c), h = ctrlH(c);
      snapLines = []; let bx = ALIGN, by = ALIGN;
      p.controls.filter(o => o.id !== c.id).forEach(o => {
        const ow = ctrlW(o), oh = ctrlH(o);
        [[x, o.x], [x + w, o.x + ow], [x + w / 2, o.x + ow / 2], [x, o.x + ow], [x + w, o.x]].forEach(([a, b]) => {
          const d = a - b; if (Math.abs(d) < Math.abs(bx)) { bx = d; snapLines = snapLines.filter(l => l.axis !== 'x'); snapLines.push({ axis: 'x', pos: b }); }
        });
        [[y, o.y], [y + h, o.y + oh], [y + h / 2, o.y + oh / 2], [y, o.y + oh], [y + h, o.y]].forEach(([a, b]) => {
          const d = a - b; if (Math.abs(d) < Math.abs(by)) { by = d; snapLines = snapLines.filter(l => l.axis !== 'y'); snapLines.push({ axis: 'y', pos: b }); }
        });
      });
      if (Math.abs(bx) < ALIGN) x -= bx; if (Math.abs(by) < ALIGN) y -= by;
      x = Math.max(0, Math.min(p.canvasW - w, x)); y = Math.max(0, Math.min(p.canvasH - h, y));
      return { x, y };
    }

    document.addEventListener('mousemove', e => {
      if (!drag) return;
      const c = p.controls.find(c => c.id === drag); if (!c) return;
      const cr = document.getElementById('plugin-canvas').getBoundingClientRect();
      const { x, y } = snapPos(c, e.clientX - cr.left - dragOff.x, e.clientY - cr.top - dragOff.y);
      c.x = x; c.y = y;
      const el = document.querySelector('.cc[data-id="' + drag + '"]');
      if (el) { el.style.left = x + 'px'; el.style.top = y + 'px'; }
      drawSnap();
    });

    document.addEventListener('mouseup', () => {
      if (drag) { snapshot(); drag = null; snapLines = []; drawSnap(); renderCtrls(); renderInspector(); }
    });

    document.getElementById('cvs-ctrls').addEventListener('click', e => {
      if (e.target === e.currentTarget) selCtrl(null);
    });

    // â”€â”€ CONTROL LIST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderCtrlList() {
      const list = document.getElementById('ctrl-list'); list.innerHTML = '';
      p.controls.forEach(c => {
        const row = document.createElement('div');
        row.className = 'ctrl-row' + (selID === c.id ? ' sel' : '');
        row.innerHTML = `<span class="ctrl-icon">${c.type === 'knob' ? 'ðŸŽ›' : 'ðŸŽš'}</span>
      <div class="ctrl-meta"><div class="ctrl-name" data-id="${c.id}">${c.label}</div><div class="ctrl-pid" data-id="${c.id}">${c.paramID}</div></div>
      <span class="ctrl-del" onclick="delCtrl('${c.id}',event)">âœ•</span>`;
        row.addEventListener('click', () => selCtrl(c.id));
        list.appendChild(row);
      });
    }

    function selCtrl(id) { selID = id; renderCtrls(); renderCtrlList(); renderInspector(); }

    function duplicateSelected() {
      if (!selID) return;
      snapshot();
      const src = p.controls.find(c => c.id === selID); if (!src) return;
      const nc = clone(src); nc.id = 'c' + Date.now(); nc.x += 20; nc.y += 20;
      p.controls.push(nc); selCtrl(nc.id);
    }

    function addCtrl(type) {
      snapshot();
      const n = p.controls.length, tmpl = p.controls[0] || {};
      const id = 'c' + Date.now();
      // New controls inherit activePalette colors (the last-used color combo)
      p.controls.push({
        id, paramID: 'param' + (n + 1), label: type === 'knob' ? 'KNOB ' + (n + 1) : 'SLD ' + (n + 1),
        type, x: 50 + (n % 3) * 140, y: 60 + Math.floor(n / 3) * 160, size: type === 'knob' ? 100 : 100,
        min: 0, max: 1, def: 0.5,
        knobStyle: tmpl.knobStyle || 'classic', thumbShape: tmpl.thumbShape || 'rect',
        faceColor: activePalette.faceColor, ringColor: activePalette.ringColor,
        needleColor: activePalette.needleColor, labelColor: activePalette.labelColor,
        bgColor: activePalette.bgColor || '#000000', trackFillColor: activePalette.trackFillColor || '#222222',
        dotColor: activePalette.dotColor || '#ffffff', highlightColor: activePalette.highlightColor || '#ffffff',
        fontSize: 10, showLabel: true
      });
      selCtrl(id);
    }

    function delCtrl(id, e) {
      if (e) e.stopPropagation();
      snapshot();
      p.controls = p.controls.filter(c => c.id !== id);
      if (selID === id) selID = null;
      renderCanvas(); renderCtrlList(); renderInspector();
    }

    function setGrid(on) {
      p.showGrid = on;
      document.getElementById('gon').classList.toggle('on', on);
      document.getElementById('goff').classList.toggle('on', !on);
      drawGrid();
    }

    // â”€â”€ INSPECTOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderInspector() {
      const cont = document.getElementById('insp-content');
      const c = p.controls.find(c => c.id === selID);
      if (!c) {
        cont.innerHTML = `<div id="no-sel">
      <div style="font-size:28px;margin-bottom:10px">ðŸŽ›</div>
      Select a control to edit it.<br><br>
      <div style="font-size:10px;color:var(--muted);line-height:1.8">
        <strong style="color:var(--muted2)">Shortcuts</strong><br>
        Delete â€” remove<br>Cmd+D â€” duplicate<br>Arrow keys â€” nudge<br>Shift+Arrow â€” nudge Ã—10<br>Esc â€” deselect
      </div>
    </div>`;
        return;
      }

      const kpick = KNOB_STYLES.map(st => {
        const sw = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        buildKnob(sw, { ...c, size: 36, knobStyle: st, id: 'prev' + st }, 0.45);
        const tmp = document.createElement('div'); tmp.appendChild(sw);
        return `<div class="kp-opt${c.knobStyle === st ? ' on' : ''}" onclick="updC('${c.id}','knobStyle','${st}')">
      ${tmp.innerHTML}<div class="kp-lbl">${st}</div></div>`;
      }).join('');

      const tpick = c.type === 'slider' ? `<div class="isec">
    <div class="sec-title">Thumb Shape</div>
    <div class="tp-row">
      ${['rect', 'circle', 'square'].map(sh => `<div class="tp-opt${c.thumbShape === sh ? ' on' : ''}" onclick="updC('${c.id}','thumbShape','${sh}')">
        <svg width="32" height="24">${sh === 'circle' ? `<circle cx="16" cy="12" r="9" fill="${c.needleColor}"/>` : sh === 'square' ? `<rect x="5" y="4" width="22" height="16" rx="2" fill="${c.needleColor}"/>` :
          `<rect x="1" y="6" width="30" height="12" rx="5" fill="${c.needleColor}"/>`}</svg>
        <div class="tp-lbl">${sh}</div>
      </div>`).join('')}
    </div></div>`: '';

      const mn = c.min != null ? c.min : 0, mx = c.max != null ? c.max : 1, df = c.def != null ? c.def : 0.5;

      cont.innerHTML = `
  <div class="isec">
    <div class="sec-title">Control</div>
    <div class="irow"><span class="ilbl">Label</span><input class="iinp" value="${c.label}" 
      oninput="updC('${c.id}','label',this.value)"
      onblur="snapshot();renderInspector()"></div>
    <div class="irow"><span class="ilbl">Param ID</span><input class="iinp" value="${c.paramID}" 
      oninput="updC('${c.id}','paramID',this.value)"
      onblur="snapshot();renderInspector()"></div>
    <div class="irow"><span class="ilbl">Type</span>
      <div class="iseg">
        <button class="iseg-b${c.type === 'knob' ? ' on' : ''}" onclick="updC('${c.id}','type','knob')">Knob</button>
        <button class="iseg-b${c.type === 'slider' ? ' on' : ''}" onclick="updC('${c.id}','type','slider')">Slider</button>
      </div>
    </div>
  </div>
  <div class="isec">
    <div class="sec-title">Parameter Range</div>
    <div class="irow"><span class="ilbl">Min</span><input class="iinp" type="number" value="${mn}" oninput="updCN('${c.id}','min',this.value)"></div>
    <div class="irow"><span class="ilbl">Max</span><input class="iinp" type="number" value="${mx}" oninput="updCN('${c.id}','max',this.value)"></div>
    <div class="irow"><span class="ilbl">Default</span><input class="iinp" type="number" value="${df}" oninput="updCN('${c.id}','def',this.value)"></div>
  </div>
  ${c.type === 'knob' ? `<div class="isec"><div class="sec-title">Knob Style</div><div class="kp-grid">${kpick}</div></div>` : ''}
  ${tpick}
  <div class="isec">
    <div class="sec-title">Position &amp; Size</div>
    <div class="irow"><span class="ilbl">X</span><input class="iinp" type="number" value="${Math.round(c.x)}" oninput="updCN('${c.id}','x',this.value)"></div>
    <div class="irow"><span class="ilbl">Y</span><input class="iinp" type="number" value="${Math.round(c.y)}" oninput="updCN('${c.id}','y',this.value)"></div>
    <div class="irow">
      <span class="ilbl">${c.type === 'knob' ? 'Diameter' : 'Height'}</span>
      <div class="size-stepper">
        <button class="size-btn" onclick="stepSize('${c.id}',-10)">âˆ’</button>
        <input class="size-val" type="number" value="${c.size}" min="30" max="280"
          oninput="updCN('${c.id}','size',this.value)">
        <button class="size-btn" onclick="stepSize('${c.id}',10)">+</button>
      </div>
    </div>
  </div>
  <div class="isec">
    <div class="sec-title" style="display:flex;align-items:center;justify-content:space-between">
      Colors
      <button class="save-pal-btn" onclick="savePalette('${c.id}')">ï¼‹ Save combo</button>
    </div>
    ${renderPaletteSwatches('${c.id}')}
    <div style="font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:.1em;margin-bottom:4px;margin-top:2px">Knob / Slider</div>
    <div class="irow"><span class="ilbl">Face</span><input type="color" class="iinp" value="${c.faceColor}" oninput="updColor('${c.id}','faceColor',this.value)"></div>
    <div class="irow"><span class="ilbl">Ring/Track</span><input type="color" class="iinp" value="${c.ringColor}" oninput="updColor('${c.id}','ringColor',this.value)"></div>
    <div class="irow"><span class="ilbl">Needle/Thumb</span><input type="color" class="iinp" value="${c.needleColor}" oninput="updColor('${c.id}','needleColor',this.value)"></div>
    <div class="irow"><span class="ilbl">Background</span><input type="color" class="iinp" value="${c.bgColor || '#111111'}" oninput="updColor('${c.id}','bgColor',this.value)"></div>
    <div class="irow"><span class="ilbl">Track Fill</span><input type="color" class="iinp" value="${c.trackFillColor || '#1a1a1a'}" oninput="updColor('${c.id}','trackFillColor',this.value)"></div>
    <div class="irow"><span class="ilbl">Dot/Center</span><input type="color" class="iinp" value="${c.dotColor || '#ffffff'}" oninput="updColor('${c.id}','dotColor',this.value)"></div>
    <div class="irow"><span class="ilbl">Highlight</span><input type="color" class="iinp" value="${c.highlightColor || '#ffffff'}" oninput="updColor('${c.id}','highlightColor',this.value)"></div>
    <div style="font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:.1em;margin-bottom:4px;margin-top:6px">Label</div>
    <div class="irow"><span class="ilbl">Label Color</span><input type="color" class="iinp" value="${c.labelColor}" oninput="updColor('${c.id}','labelColor',this.value)"></div>
    <button class="apply-all-btn" onclick="applyColorsToAll('${c.id}')">Apply these colors to all controls</button>
    <div style="margin-top:6px">
      <div style="font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:.1em;margin-bottom:4px">Copy colors from another control</div>
      <div style="display:flex;gap:5px;align-items:center">
        <select id="copy-from-sel" style="flex:1;background:var(--surface3);border:1px solid var(--border2);border-radius:5px;color:var(--text);padding:4px 7px;font-family:'Syne',sans-serif;font-size:11px;outline:none;">
          ${p.controls.filter(o => o.id !== '${c.id}').map(o => `<option value="${o.id}">${o.label} (${o.paramID})</option>`).join('')}
        </select>
        <button onclick="copyColorsFrom('${c.id}', document.getElementById('copy-from-sel').value)"
          style="background:var(--surface3);border:1px solid var(--border2);color:var(--text);padding:4px 10px;border-radius:5px;cursor:pointer;font-size:11px;font-weight:600;font-family:'Syne',sans-serif;white-space:nowrap;">
          Copy
        </button>
      </div>
    </div>
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
        <div style="font-size:11px;color:var(--muted2);font-weight:600">Thumb Indicator</div>
        <div class="iseg" style="width:120px">
          <button class="iseg-b${c.thumbLine === 'line' ? ' on' : ''}" onclick="updC('${c.id}','thumbLine','line')">Line</button>
          <button class="iseg-b${c.thumbLine === 'dots' || c.thumbLine === true ? ' on' : ''}" onclick="updC('${c.id}','thumbLine','dots')">Dots</button>
          <button class="iseg-b${!c.thumbLine && c.thumbLine !== true ? ' on' : ''}" onclick="updC('${c.id}','thumbLine',false)">None</button>
        </div>
      </div>
      ${c.thumbLine ? `<div class="irow"><span class="ilbl">Color</span><input type="color" class="iinp" value="${c.thumbLineColor || '#ffffff'}" oninput="updColor('${c.id}','thumbLineColor',this.value)"></div>` : ''}
  </div>
  <div class="isec">
    <div class="sec-title">Label</div>
    <div class="irow"><span class="ilbl">Show</span>
      <div class="iseg">
        <button class="iseg-b${c.showLabel ? ' on' : ''}" onclick="updC('${c.id}','showLabel',true)">Yes</button>
        <button class="iseg-b${!c.showLabel ? ' on' : ''}" onclick="updC('${c.id}','showLabel',false)">No</button>
      </div>
    </div>
    <div class="irow"><span class="ilbl">Font Size</span><input class="iinp" type="number" value="${c.fontSize}" oninput="updCN('${c.id}','fontSize',this.value)"></div>
  </div>
  <div class="isec" style="display:flex;gap:6px">
    <button class="danger-btn" onclick="delCtrl('${c.id}')" style="flex:1">ðŸ—‘ Delete</button>
    <button style="flex:1;background:rgba(79,138,255,.12);border:1px solid rgba(79,138,255,.3);color:var(--accent);padding:7px;border-radius:7px;cursor:pointer;font-size:12px;font-weight:600;font-family:'Syne',sans-serif;" onclick="duplicateSelected()">â§‰ Duplicate</button>
  </div>`;
    }

    function updC(id, key, val) {
      const c = p.controls.find(c => c.id === id); if (!c) return;
      // Only snapshot for non-text fields (text fields snapshot on blur)
      if (key !== "label" && key !== "paramID") snapshot();
      c[key] = val;
      renderCanvas(); renderCtrlList();
      // Only re-render inspector for non-text fields to avoid cursor reset
      if (key !== 'label' && key !== 'paramID') {
        renderInspector();
      } else {
        // Just update the ctrl list label without blowing up the inspector
        const pid = document.querySelector('.ctrl-pid[data-id="' + id + '"]');
        if (pid && key === 'paramID') pid.textContent = val;
        const nm = document.querySelector('.ctrl-name[data-id="' + id + '"]');
        if (nm && key === 'label') nm.textContent = val;
      }
    }
    function updCN(id, key, val) { updC(id, key, parseFloat(val) || 0); }

    // â”€â”€ SAVE / LOAD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function saveProject() {
      const blob = new Blob([JSON.stringify({ brand: currentBrand, project: p }, null, 2)], { type: 'application/json' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = p.pluginName + '.scproj'; a.click();
      toast('Project saved!');
    }
    function loadProject() {
      // Remove any previous hidden input to avoid stale handlers
      const old = document.getElementById('_sc_file_inp');
      if (old) old.remove();
      const inp = document.createElement('input'); inp.type = 'file'; inp.accept = '.scproj,.json';
      inp.id = '_sc_file_inp'; inp.style.cssText = 'position:fixed;top:-999px;opacity:0;';
      document.body.appendChild(inp);
      inp.onchange = e => {
        const f = e.target.files[0]; if (!f) return;
        const r = new FileReader(); r.onload = ev => {
          try {
            const d = JSON.parse(ev.target.result);
            if (d.brand && d.project) { currentBrand = d.brand; p = d.project; } else { p = d; }
            // Migrate old projects: fill in any missing color fields with sensible defaults
            p.controls.forEach(c => {
              if (!c.bgColor) c.bgColor = 'transparent';
              if (!c.trackFillColor) c.trackFillColor = c.ringColor || '#333333';
              if (!c.dotColor) c.dotColor = c.faceColor ? darken(c.faceColor, 15) : '#111111';
              if (!c.highlightColor) c.highlightColor = '#ffffff';
            });
            selID = null; syncSidebar(); renderCanvas(); renderCtrlList(); renderInspector(); buildBrandSwitcher();
            toast('Project loaded!');
          } catch (err) { alert('Could not load: ' + err.message); }
        }; r.readAsText(f);
      };
      // Small delay ensures DOM is ready before click â€” fixes first-click issue
      setTimeout(() => inp.click(), 10);
    }

    // â”€â”€ TOAST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function toast(msg) {
      const t = document.getElementById('toast'); t.textContent = msg; t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 2000);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  CODE GENERATION  â€” full plugin package
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function jc(hex) {
      if (!hex) return '0xff000000';
      if (hex === 'transparent' || hex === 'rgba(0,0,0,0)') return '0x00000000';
      if (hex.startsWith('rgba')) {
        const m = hex.match(/rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/);
        if (m) {
          const a = Math.round(parseFloat(m[4]) * 255).toString(16).padStart(2, '0');
          const r = parseInt(m[1]).toString(16).padStart(2, '0');
          const g = parseInt(m[2]).toString(16).padStart(2, '0');
          const b = parseInt(m[3]).toString(16).padStart(2, '0');
          return `0x${a}${r}${g}${b}`.toUpperCase();
        }
      }
      return `0xff${hex.slice(1).toUpperCase()}`;
    }

    // â”€â”€ CMakeLists.txt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function genCMake() {
      const name = sanitize(p.pluginName);
      return `cmake_minimum_required(VERSION 3.22)
          project(${name} VERSION 1.0.0)

          set(CMAKE_CXX_STANDARD 17)
          set(CMAKE_OSX_DEPLOYMENT_TARGET "13.0" CACHE STRING "")

# â”€â”€ Download JUCE automatically(no install needed) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          include(FetchContent)
          FetchContent_Declare(
            JUCE
    GIT_REPOSITORY https://github.com/juce-framework/JUCE.git
            GIT_TAG        8.0.4
    GIT_SHALLOW    TRUE
          )
          FetchContent_MakeAvailable(JUCE)

# â”€â”€ Plugin target â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          juce_add_plugin(${name}
    COMPANY_NAME             "${p.companyName}"
    PLUGIN_CODE              ${p.pluginCode || 'DmVb'}
    COMPANY_CODE             ${p.companyCode || 'SdCp'}
    FORMATS                  VST3 AU Standalone
    PRODUCT_NAME             "${p.pluginName}"
    IS_SYNTH                 FALSE
    NEEDS_MIDI_INPUT         FALSE
    NEEDS_MIDI_OUTPUT        FALSE
    IS_MIDI_EFFECT           FALSE
    EDITOR_WANTS_KEYBOARD_FOCUS FALSE
    COPY_PLUGIN_AFTER_BUILD  TRUE)

          target_sources(${name} PRIVATE
    Source / PluginProcessor.cpp
    Source / PluginEditor.cpp)

          target_compile_definitions(${name} PUBLIC
    JUCE_WEB_BROWSER = 0
    JUCE_USE_CURL = 0
    JUCE_VST3_CAN_REPLACE_VST2 = 0
    JUCE_DISPLAY_SPLASH_SCREEN = 0)

          target_link_libraries(${name}
    PRIVATE
        juce:: juce_audio_utils
        juce:: juce_dsp
        juce:: juce_gui_basics
    PUBLIC
        juce:: juce_recommended_config_flags
        juce:: juce_recommended_lto_flags
        juce:: juce_recommended_warning_flags)`;
    }

    // â”€â”€ build.sh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function genBuildSh() {
      const name = sanitize(p.pluginName);
      const pluginName = p.pluginName;
      const companyName = p.companyName;
      const lines = [
        "#!/bin/bash",
        "set -euo pipefail",
        "",
        'echo ""',
        'echo "======================================"',
        'echo "  ' + pluginName + ' â€” Sound Capsule Build"',
        'echo "======================================"',
        'echo ""',
        "",
        "# 1. Xcode Command Line Tools",
        "if ! xcode-select -p &>/dev/null; then",
        '  echo "Installing Xcode Command Line Tools..."',
        "  xcode-select --install",
        '  echo "Run this script again once Xcode CLT finishes installing."',
        "  exit 0",
        "fi",
        'echo "OK: Xcode CLT found"',
        "",
        "# 2. Homebrew",
        "if ! command -v brew &>/dev/null; then",
        '  echo "Installing Homebrew..."',
        '  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"',
        '  eval "$(/opt/homebrew/bin/brew shellenv)" 2>/dev/null || true',
        '  eval "$(/usr/local/bin/brew shellenv)" 2>/dev/null || true',
        "fi",
        'echo "OK: Homebrew found"',
        "",
        "# 3. cmake + git",
        "command -v cmake &>/dev/null || brew install cmake",
        "command -v git   &>/dev/null || brew install git",
        'echo "OK: cmake and git ready"',
        "",
        "# 4. Configure â€” downloads JUCE automatically (first run ~200MB)",
        'echo ""',
        'echo "Configuring... first run downloads JUCE, grab a coffee."',
        "cmake -B build -DCMAKE_BUILD_TYPE=Release",
        "",
        "# 5. Compile",
        'echo ""',
        'echo "Building ' + pluginName + '..."',
        "CORES=$(sysctl -n hw.logicalcpu)",
        "cmake --build build --config Release --parallel $CORES",
        "",
        "# 6. Install",
        'VST3_SRC=$(find build -name "' + name + '.vst3" -type d 2>/dev/null | head -1)',
        'VST3_DIR="$HOME/Library/Audio/Plug-Ins/VST3"',
        'mkdir -p "$VST3_DIR"',
        "",
        'if [ -n "$VST3_SRC" ]; then',
        '  rm -rf "$VST3_DIR/' + name + '.vst3"',
        '  cp -r "$VST3_SRC" "$VST3_DIR/"',
        '  echo ""',
        '  echo "======================================"',
        '  echo "  DONE: ' + pluginName + '.vst3 installed!"',
        '  echo "======================================"',
        '  echo ""',
        '  echo "Open Ableton > Preferences > Plug-Ins > Rescan"',
        '  echo "Find: ' + companyName + ' > ' + pluginName + '"',
        '  echo ""',
        "else",
        '  echo "ERROR: .vst3 not found after build. Check the build/ folder."',
        "  exit 1",
        "fi"
      ];
      return lines.join("\n");
    }
    // â”€â”€ PluginProcessor.h â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function genProcessorH() {
      const name = sanitize(p.pluginName);
      return `#pragma once
          #include < juce_audio_processors / juce_audio_processors.h >
            #include < juce_dsp / juce_dsp.h >

            class $ { name }Processor: public juce::AudioProcessor {
            public:
    ${name} Processor();
            ~${name} Processor() override = default ;

            void prepareToPlay(double sampleRate, int samplesPerBlock) override;
            void releaseResources() override { }
            void processBlock(juce:: AudioBuffer < float >&, juce:: MidiBuffer &) override;

            juce:: AudioProcessorEditor * createEditor() override;
    bool hasEditor() const override { return true;
          }
          const juce:: String getName() const override { return "${p.pluginName}";
        }
    bool acceptsMidi() const override { return false;
      }
    bool producesMidi() const override { return false;
    }
    double getTailLengthSeconds() const override { return 2.0; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override { }
    const juce:: String getProgramName(int) override { return {}; }
    void changeProgramName(int, const juce:: String&) override { }
    void getStateInformation(juce:: MemoryBlock &) override;
    void setStateInformation(const void*, int) override;

    juce::AudioProcessorValueTreeState apvts;
    static juce:: AudioProcessorValueTreeState::ParameterLayout createParams();

    private:
    // â”€â”€ DSP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    juce:: dsp::Reverb reverb;
    juce:: dsp:: Reverb::Parameters reverbParams;

    // Filters
    using Filter = juce:: dsp:: IIR:: Filter<float>;
      using FilterCoeffs = juce::dsp::IIR::Coefficients<float>;
        juce::dsp::ProcessorDuplicator<Filter, FilterCoeffs> loFilter, hiFilter;

        // Modulation LFO
        float lfoPhase {0.f };
        double sampleRate {44100.0};

        // Helpers
        void applyParams();

        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(${name}Processor)
};`;
    }

    // â”€â”€ PluginProcessor.cpp â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function genProcessorCpp() {
      const name = sanitize(p.pluginName);

      // Map controls to reverb semantic fields by paramID keywords
      function paramLine(pid, field, unit = '') {
        return `    reverbParams.${field} = *apvts.getRawParameterValue("${pid}");`;
      }

      // Build parameter declarations
      const paramLayout = p.controls.map(c => {
        const pid = sanitize(c.paramID);
        const mn = c.min != null ? c.min : 0, mx = c.max != null ? c.max : 1, df = c.def != null ? c.def : 0.5;
        return `        std::make_unique<juce::AudioParameterFloat>(
        "${pid}", "${c.label}", ${mn}f, ${mx}f, ${df}f)`;
      }).join(',\n');

      // Auto-map first 4 reverb params to JUCE Reverb fields
      const reverbFields = ['roomSize', 'damping', 'wetLevel', 'width'];
      const reverbMaps = p.controls.slice(0, 4).map((c, i) =>
        `    reverbParams.${reverbFields[i]} = *apvts.getRawParameterValue("${sanitize(c.paramID)}");`
      ).join('\n');

      // Find predelay, lowCut, highCut, modDepth, modRate by paramID if present
      function findParam(keywords) {
        const c = p.controls.find(c => keywords.some(k => c.paramID.toLowerCase().includes(k)));
        return c ? `"${sanitize(c.paramID)}"` : null;
      }
      const lowCutId = findParam(['lowcut', 'locut', 'low', 'lp', 'lowpass']);
      const hiCutId = findParam(['highcut', 'hicut', 'high', 'hi', 'hp', 'hipass']);
      const modDepthId = findParam(['moddepth', 'mod', 'depth']);
      const modRateId = findParam(['modrate', 'rate', 'speed']);
      const mixId = findParam(['mix', 'wet']);

      return `#include "PluginProcessor.h"
        #include "PluginEditor.h"

        ${name}Processor::${name}Processor()
        : AudioProcessor(BusesProperties()
        .withInput ("Input",  juce::AudioChannelSet::stereo(), true)
        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
        apvts(*this, nullptr, "Parameters", createParams())
        {
        }

        juce::AudioProcessorValueTreeState::ParameterLayout ${name}Processor::createParams(){
    return {
          ${paramLayout}
    };
}

        void ${name}Processor::prepareToPlay(double sr, int samplesPerBlock){
          sampleRate = sr;
        juce::dsp::ProcessSpec spec;
        spec.sampleRate = sr;
        spec.maximumBlockSize = (juce::uint32)samplesPerBlock;
        spec.numChannels = (juce::uint32)getTotalNumOutputChannels();

        reverb.prepare(spec);
        reverb.reset();

        loFilter.prepare(spec);
        hiFilter.prepare(spec);
        lfoPhase = 0.f;
}

        void ${name}Processor::applyParams(){
          ${reverbMaps}
        reverbParams.dryLevel = 1.f - reverbParams.wetLevel;
        reverb.setParameters(reverbParams);

        // Low-cut filter
        ${lowCutId ? `    float lowFreq = *apvts.getRawParameterValue(${lowCutId});
    *loFilter.state = *juce::dsp::IIR::Coefficients<float>::makeHighPass(sampleRate, lowFreq);`
          : '    *loFilter.state = *juce::dsp::IIR::Coefficients<float>::makeHighPass(sampleRate, 80.f);'}

    // High-cut filter
        ${hiCutId ? `    float hiFreq = *apvts.getRawParameterValue(${hiCutId});
    *hiFilter.state = *juce::dsp::IIR::Coefficients<float>::makeLowPass(sampleRate, hiFreq);`
          : '    *hiFilter.state = *juce::dsp::IIR::Coefficients<float>::makeLowPass(sampleRate, 8000.f);'}
}

        void ${name}Processor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&){
          juce::ScopedNoDenormals noDenormals;
          applyParams();

          // Modulation (subtle pitch variation via LFO)
          ${modDepthId && modRateId ? `    float modDepth = *apvts.getRawParameterValue(${modDepthId});
    float modRate  = *apvts.getRawParameterValue(${modRateId});
    float lfoInc   = juce::MathConstants<float>::twoPi * modRate / (float)sampleRate;
    for(int ch = 0; ch < buffer.getNumChannels(); ++ch){
        auto* data = buffer.getWritePointer(ch);
        for(int i = 0; i < buffer.getNumSamples(); ++i){
            data[i] *= (1.f + modDepth * 0.005f * std::sin(lfoPhase));
            lfoPhase = std::fmod(lfoPhase + lfoInc, juce::MathConstants<float>::twoPi);
        }
    }`: '    // (no modulation params found â€” add modDepth / modRate controls to enable)'}

          juce::dsp::AudioBlock<float> block(buffer);
            juce::dsp::ProcessContextReplacing<float> ctx(block);

              loFilter.process(ctx);
              reverb.process(ctx);
              hiFilter.process(ctx);
}

              void ${name}Processor::getStateInformation(juce::MemoryBlock& destData){
                auto state = apvts.copyState();
              std::unique_ptr<juce::XmlElement> xml(state.createXml());
              copyXmlToBinary(*xml, destData);
}

              void ${name}Processor::setStateInformation(const void* data, int sizeInBytes){
                std::unique_ptr<juce::XmlElement> xml(getXmlFromBinary(data, sizeInBytes));
    if(xml && xml->hasTagName(apvts.state.getType()))
              apvts.replaceState(juce::ValueTree::fromXml(*xml));
}

              juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter(){
    return new ${name}Processor();
}`;
    }

    // â”€â”€ PluginEditor.h â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function genEditorH() {
      const name = sanitize(p.pluginName);
      const knobs = p.controls.filter(c => c.type === 'knob');
      const sliders = p.controls.filter(c => c.type === 'slider');
      const f = p.controls[0] || { faceColor: '#0d1f33', ringColor: '#4f8aff', needleColor: '#00d4aa', labelColor: '#8ecfe8' };
      return `#pragma once
              #include <juce_audio_processors /juce_audio_processors.h>
              #include <juce_gui_basics /juce_gui_basics.h>
              #include <juce_dsp /juce_dsp.h>
              #include "PluginProcessor.h"

              namespace PC {
                inline const juce::Colour bg   {${jc(p.bgColor)} };
              inline const juce::Colour ring {${jc(f.ringColor)} };
              inline const juce::Colour face {${jc(f.faceColor)} };
              inline const juce::Colour ndl  {${jc(f.needleColor)} };
              inline const juce::Colour lbl  {${jc(f.labelColor)} };
}

              class ${name}LAF : public juce::LookAndFeel_V4 {
                public:
              ${name}LAF(){
                setColour(juce::Slider::textBoxTextColourId,    PC::lbl);
              setColour(juce::Slider::textBoxOutlineColourId, juce::Colours::transparentBlack);
              setColour(juce::Label::textColourId,            PC::lbl);
    }
              void drawRotarySlider(juce::Graphics& g,int x,int y,int w,int h,
              float pos,float startA,float endA,juce::Slider& sl) override {
                float cx=x+w*.5f,cy=y+h*.5f,outerR=juce::jmin(w,h)*.48f,innerR=outerR*.78f;
              juce::String sName = sl.getName();
              juce::Colour rCol = PC::ring, fCol = PC::face, nCol = PC::ndl;
              ${knobs.map(c => `if(sName=="${sanitize(c.paramID)}"){ rCol=juce::Colour(${jc(c.ringColor)}); fCol=juce::Colour(${jc(c.faceColor)}); nCol=juce::Colour(${jc(c.needleColor)}); }`).join('else ')}

        // Outer glow ring
              g.setColour(rCol.withAlpha(.18f));
              g.fillEllipse(cx-outerR-3.f,cy-outerR-3.f,(outerR+3.f)*2.f,(outerR+3.f)*2.f);
              g.setColour(rCol); g.fillEllipse(cx-outerR,cy-outerR,outerR*2.f,outerR*2.f);
              g.setColour(fCol); g.fillEllipse(cx-innerR,cy-innerR,innerR*2.f,innerR*2.f);

              // Arc track
              auto toXY=[&](float r,float a){ return juce::Point<float>(cx+std::sin(a)*r,cy-std::cos(a)*r); };
                float angle=startA+pos*(endA-startA);
                juce::Path arc; arc.addCentredArc(cx,cy,outerR*.91f,outerR*.91f,0.f,startA,endA,true);
                g.setColour(rCol.withAlpha(.25f));
                g.strokePath(arc,juce::PathStrokeType(outerR*.1f,juce::PathStrokeType::curved,juce::PathStrokeType::rounded));

                // Horizontal line for param9, otherwise standard needle pointing to angle
                if (sName == "param9") {
                  g.setColour(nCol);
                g.drawLine(cx - innerR * 0.7f, cy, cx + innerR * 0.7f, cy, 3.f);
        } else {
                  auto tip=toXY(innerR*.72f,angle),tail=toXY(innerR*.18f,angle+juce::MathConstants<float>::pi);
                    g.setColour(nCol);
                    juce::Path n; n.startNewSubPath(tail); n.lineTo(tip);
                    g.strokePath(n,juce::PathStrokeType(3.f,juce::PathStrokeType::curved,juce::PathStrokeType::rounded));
        }
    }
                    void drawLinearSlider(juce::Graphics& g,int x,int y,int w,int h,
                    float pos,float,float,juce::Slider::SliderStyle style,juce::Slider& sl) override {
        if(style!=juce::Slider::LinearVertical){LookAndFeel_V4::drawLinearSlider(g,x,y,w,h,pos,0,0,style,sl);return;}
                  float cx=x+w*.5f,trackW=7.f;
                  juce::String sliderName = sl.getName();
                  juce::Colour tCol = PC::face;
                  juce::Colour nCol = PC::ndl;

                  ${sliders.map(c => `if(sliderName=="${sanitize(c.paramID)}"){ tCol=juce::Colour(${jc(c.trackFillColor || c.faceColor)}); nCol=juce::Colour(${jc(c.needleColor)}); }`).join('else ')}

                  if (!tCol.isTransparent()) {
                    g.setColour(tCol);
                  g.fillRoundedRectangle(cx-trackW*.5f,(float)y,trackW,(float)h,trackW*.5f);
        }

                  float tw=32.f,th=18.f;
                  g.setColour(nCol);
                  g.fillRoundedRectangle(cx-tw*.5f,pos-th*.5f,tw,th,5.f);

                  // Base logic for thumb styling directly mapped from the HTML tool's thumbLine setting
                  ${sliders.map(c => `
        if (sliderName == "${sanitize(c.paramID)}") {
            ${c.thumbLine === 'dots' || c.thumbLine === true || (!c.thumbLine && c.thumbLine !== false) ? `
            g.setColour(juce::Colours::white.withAlpha(0.25f));
            g.fillRoundedRectangle(cx-tw*.5f+3.f, pos-th*.5f+3.f, tw-6.f, 3.f, 1.5f);
            ` : ''}
            ${c.thumbLine === 'line' ? `
            g.setColour(juce::Colour(${jc(c.thumbLineColor || '#ffffff')}));
            g.drawLine(cx-tw*.5f+2.f, pos, cx+tw*.5f-2.f, pos, 2.5f);
            ` : c.thumbLine === 'dots' || c.thumbLine === true ? `
            g.setColour(juce::Colour(${jc(c.dotColor || '#ffffff')}).withAlpha(0.55f));
            g.fillEllipse(cx-1.5f, pos-3.f-1.5f, 3.f, 3.f);
            g.fillEllipse(cx-1.5f, pos-1.5f, 3.f, 3.f);
            g.fillEllipse(cx-1.5f, pos+3.f-1.5f, 3.f, 3.f);
            ` : ''}
        }`).join(' else ')}
    }
};

                  class ${name}Editor : public juce::AudioProcessorEditor {
                    public:
                  explicit ${name}Editor(${name}Processor&);
                  ~${name}Editor() override;
                  void paint(juce::Graphics&) override;
                  void resized() override;
                  private:
                  ${name}Processor& proc;
                  ${name}LAF laf;
                  ${knobs.map(c => `    juce::Slider ${sanitize(c.paramID)}Knob{juce::Slider::RotaryHorizontalVerticalDrag,juce::Slider::NoTextBox};`).join('\n')}
                  ${sliders.map(c => `    juce::Slider ${sanitize(c.paramID)}Slider{juce::Slider::LinearVertical,juce::Slider::NoTextBox};`).join('\n')}
                  ${p.controls.map(c => `    juce::Label ${sanitize(c.paramID)}Lbl;`).join('\n')}
                  juce::Label brandLbl,productLbl;
                  using Att=juce::AudioProcessorValueTreeState::SliderAttachment;
                  ${p.controls.map(c => `    std::unique_ptr<Att> ${sanitize(c.paramID)}Att;`).join('\n')}
                  void setupLbl(juce::Label&,const juce::String&);
                  JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(${name}Editor)
};`;
    }

    // â”€â”€ PluginEditor.cpp â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function genEditorCpp() {
      const name = sanitize(p.pluginName);
      const adds = p.controls.map(c => c.type === 'knob'
        ? `    ${sanitize(c.paramID)}Knob.setName("${sanitize(c.paramID)}"); addAndMakeVisible(${sanitize(c.paramID)}Knob); ${sanitize(c.paramID)}Knob.setLookAndFeel(&laf);\n    setupLbl(${sanitize(c.paramID)}Lbl,"${c.label.toUpperCase()}");\n    ${sanitize(c.paramID)}Att=std::make_unique<Att>(proc.apvts,"${sanitize(c.paramID)}",${sanitize(c.paramID)}Knob);`
        : `    ${sanitize(c.paramID)}Slider.setName("${sanitize(c.paramID)}"); addAndMakeVisible(${sanitize(c.paramID)}Slider); ${sanitize(c.paramID)}Slider.setLookAndFeel(&laf);\n    setupLbl(${sanitize(c.paramID)}Lbl,"${c.label.toUpperCase()}");\n    ${sanitize(c.paramID)}Att=std::make_unique<Att>(proc.apvts,"${sanitize(c.paramID)}",${sanitize(c.paramID)}Slider);`
      ).join('\n');
      const bounds = p.controls.map(c => {
        const ix = Math.round(c.x), iy = Math.round(c.y), sz = Math.round(c.size);
        return c.type === 'knob'
          ? `    ${sanitize(c.paramID)}Knob.setBounds(${ix},${iy},${sz},${sz});\n    ${sanitize(c.paramID)}Lbl.setBounds(${ix},${iy + sz + 2},${sz},16);`
          : `    ${sanitize(c.paramID)}Slider.setBounds(${ix},${iy},44,${sz});\n    ${sanitize(c.paramID)}Lbl.setBounds(${ix - 4},${iy + sz + 2},52,16);`;
      }).join('\n');
      return `#include "PluginEditor.h"
                      #include "PluginProcessor.h"

                      ${name}Editor::${name}Editor(${name}Processor& p)
                      :AudioProcessorEditor(&p),proc(p){
                        setLookAndFeel(& laf); setSize(${p.canvasW},${p.canvasH});
                      ${adds}
                      brandLbl.setText("${p.companyName.toUpperCase()}",juce::dontSendNotification);
                      brandLbl.setFont(juce::Font(juce::Font::getDefaultMonospacedFontName(),9.f,juce::Font::plain));
                      brandLbl.setColour(juce::Label::textColourId,PC::lbl.withAlpha(.45f));
                      brandLbl.setJustificationType(juce::Justification::centredRight);
                      addAndMakeVisible(brandLbl);
                      productLbl.setText("${p.pluginName.toUpperCase()}",juce::dontSendNotification);
                      productLbl.setFont(juce::Font(juce::Font::getDefaultMonospacedFontName(),13.f,juce::Font::bold));
                      productLbl.setColour(juce::Label::textColourId,PC::lbl.withAlpha(.82f));
                      productLbl.setJustificationType(juce::Justification::centredLeft);
                      addAndMakeVisible(productLbl);
}
                      ${name}Editor::~${name}Editor(){setLookAndFeel(nullptr);}
                      void ${name}Editor::setupLbl(juce::Label& l,const juce::String& t){
                        l.setText(t, juce::dontSendNotification);
                      l.setFont(juce::Font(juce::Font::getDefaultMonospacedFontName(),10.f,juce::Font::plain));
                      l.setColour(juce::Label::textColourId,PC::lbl);
                      l.setJustificationType(juce::Justification::centred);
                      addAndMakeVisible(l);
}
                      void ${name}Editor::paint(juce::Graphics& g){
                        auto b=getLocalBounds();
                      g.fillAll(PC::bg);
                      // Subtle vignette
                      juce::ColourGradient vig(juce::Colours::transparentBlack,b.getCentreX(),b.getCentreY(),
                      juce::Colours::black.withAlpha(.45f),0,0,true);
                      g.setGradientFill(vig); g.fillRect(b);
}
                      void ${name}Editor::resized(){
                        auto b=getLocalBounds();
                      productLbl.setBounds(16,12,200,22);
                      brandLbl.setBounds(b.getWidth()-190,12,174,22);
                      ${bounds}
}`;
    }

    // â”€â”€ README.md â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function genReadme() {
      const name = sanitize(p.pluginName);
      const params = p.controls.map(c => `| ${c.label} | \`${sanitize(c.paramID)}\` | ${c.min ?? 0} | ${c.max ?? 1} | ${c.def ?? 0.5} |`).join('\n');
      return `# ${p.pluginName}
> **${p.companyName}** Â· VST3 + AU Â· Built with Plugin Studio

                      ---

                      ## Build in 3 steps (Mac, one-time setup)

                      ### Step 1 â€” Unzip & open Terminal
                      Drag the unzipped \`${name}\` folder into your Desktop, then open Terminal.

                      ### Step 2 â€” Run the build script
                      \`\`\`bash
                      cd ~/Desktop/${name}
                      chmod +x build.sh
                      ./build.sh
                      \`\`\`

                      The script will:
                      - Install Homebrew if missing
                      - Install CMake + Git if missing
                      - Download JUCE automatically (~200MB, first run only)
                      - Compile ${p.pluginName}
                      - Copy \`${name}.vst3\` â†’ \`~/Library/Audio/Plug-Ins/VST3/\`

                      ### Step 3 â€” Open Ableton
                      Preferences â†’ Plug-Ins â†’ Rescan
                      Look for **${p.companyName}** in your plugin browser â†’ **${p.pluginName}** is there.

                      ---

                      ## Parameters

                      | Label | ID | Min | Max | Default |
                      |-------|----|-----|-----|---------|
                      ${params}

                      ---

                      ## Rebuild after UI changes

                      Just run \`./build.sh\` again â€” it skips the JUCE download and recompiles in ~30 seconds.

                      ---
                      *Plugin Studio Â· Sound Capsule / Plugin Corp*`;
    }

    // â”€â”€ MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function openModal() {
      const name = sanitize(p.pluginName);
      document.getElementById('modal-plgname').textContent = p.pluginName;
      document.getElementById('modal-dirname').textContent = name;
      document.getElementById('modal-cmd').innerHTML = `<span style='color:var(--muted)'>$ </span>cd ~/Desktop/${name}<br><span style='color:var(--muted)'>$ </span>chmod +x build.sh && ./build.sh`;

      const files = [
        { name: 'CMakeLists.txt', desc: 'Build system â€” connects JUCE to your source' },
        { name: 'build.sh', desc: 'Run this once â†’ .vst3 auto-installed' },
        { name: 'Source/PluginProcessor.h', desc: 'Parameter declarations + DSP engine header' },
        { name: 'Source/PluginProcessor.cpp', desc: 'Reverb DSP, filters, modulation' },
        { name: 'Source/PluginEditor.h', desc: 'UI class definition + colours' },
        { name: 'Source/PluginEditor.cpp', desc: 'Knob/slider layout from your design' },
        { name: 'README.md', desc: 'Build instructions & param reference' },
      ];
      const list = document.getElementById('modal-filelist'); list.innerHTML = '';
      files.forEach(f => {
        const row = document.createElement('div'); row.className = 'frow';
        row.innerHTML = `<span class="fname">${f.name}</span><span class="fdesc" style="flex:1;padding-left:10px">${f.desc}</span>`;
        list.appendChild(row);
      });
      document.getElementById('modal').classList.add('open');
    }

    function closeModal() { document.getElementById('modal').classList.remove('open'); }

    function copyCmd(el) {
      const text = el.innerText || el.textContent;
      navigator.clipboard.writeText(text).then(() => toast('Command copied!'));
    }

    async function downloadZip() {
      const name = sanitize(p.pluginName);
      const zip = new JSZip();
      zip.file('CMakeLists.txt', genCMake());
      zip.file('build.sh', genBuildSh());
      zip.file('README.md', genReadme());
      const src = zip.folder('Source');
      src.file('PluginProcessor.h', genProcessorH());
      src.file('PluginProcessor.cpp', genProcessorCpp());
      src.file('PluginEditor.h', genEditorH());
      src.file('PluginEditor.cpp', genEditorCpp());

      const blob = await zip.generateAsync({ type: 'blob' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name + '_PluginSource.zip';
      a.click();
      toast('Downloaded! Unzip â†’ run build.sh');
    }


    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  SIZE STEPPER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function stepSize(id, delta) {
      const c = p.controls.find(c => c.id === id); if (!c) return;
      c.size = Math.min(280, Math.max(30, (c.size || 80) + delta));
      renderCanvas(); renderInspector();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  COLOR PALETTE SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // activePalette = the "brush" â€” colors that will be applied to next new control
    let activePalette = {
      faceColor: '#8ecfc4', ringColor: '#5b8fae', needleColor: '#3a6b5a', labelColor: '#daeef2',
      bgColor: '#111111', trackFillColor: '#1a1a1a', dotColor: '#ffffff', highlightColor: '#ffffff'
    };

    // savedPalettes = named saved combos
    let savedPalettes = JSON.parse(localStorage.getItem('sc_palettes') || '[]');

    function persistPalettes() {
      try { localStorage.setItem('sc_palettes', JSON.stringify(savedPalettes)); } catch (e) { }
    }

    // When a color changes, update activePalette so next control inherits it
    let _lastColorSnap = 0;
    function updColor(id, key, val) {
      const c = p.controls.find(c => c.id === id); if (!c) return;
      const now = Date.now();
      if (now - _lastColorSnap > 300) { snapshot(); _lastColorSnap = now; }
      c[key] = val;
      // mirror to activePalette
      if (['faceColor', 'ringColor', 'needleColor', 'labelColor', 'bgColor', 'trackFillColor', 'dotColor', 'highlightColor'].includes(key)) {
        activePalette[key] = val;
      }
      // Only re-render canvas + ctrl list â€” NOT inspector
      // This keeps the color picker open while dragging the color wheel
      renderCanvas(); renderCtrlList();
      // Sync the swatch strip without full re-render
      const swatchContainer = document.querySelector('.palette-row');
      if (swatchContainer) swatchContainer.outerHTML = renderPaletteSwatches(id);
    }

    function copyColorsFrom(targetId, sourceId) {
      if (!sourceId || !targetId) return;
      const src = p.controls.find(c => c.id === sourceId);
      const tgt = p.controls.find(c => c.id === targetId);
      if (!src || !tgt) return;
      snapshot();
      const colorKeys = ['faceColor', 'ringColor', 'needleColor', 'labelColor', 'bgColor', 'trackFillColor', 'dotColor', 'highlightColor'];
      colorKeys.forEach(k => { if (src[k]) tgt[k] = src[k]; });
      renderCanvas(); renderInspector();
      toast('Colors copied from ' + src.label);
    }

    function applyColorsToAll(sourceId) {
      const src = p.controls.find(c => c.id === sourceId); if (!src) return;
      snapshot();
      p.controls.forEach(c => {
        if (c.id === sourceId) return;
        c.faceColor = src.faceColor;
        c.ringColor = src.ringColor;
        c.needleColor = src.needleColor;
        c.labelColor = src.labelColor;
        c.bgColor = src.bgColor;
        c.trackFillColor = src.trackFillColor;
        c.dotColor = src.dotColor;
        c.highlightColor = src.highlightColor;
      });
      activePalette = {
        faceColor: src.faceColor, ringColor: src.ringColor,
        needleColor: src.needleColor, labelColor: src.labelColor,
        bgColor: src.bgColor, trackFillColor: src.trackFillColor,
        dotColor: src.dotColor, highlightColor: src.highlightColor
      };
      renderCanvas(); renderInspector();
      toast('Colors applied to all controls!');
    }

    function savePalette(sourceId) {
      const src = p.controls.find(c => c.id === sourceId) || {};
      const name = prompt('Name this color combo:', 'Palette ' + (savedPalettes.length + 1));
      if (!name) return;
      savedPalettes.push({
        name,
        faceColor: src.faceColor || activePalette.faceColor,
        ringColor: src.ringColor || activePalette.ringColor,
        needleColor: src.needleColor || activePalette.needleColor,
        labelColor: src.labelColor || activePalette.labelColor,
        bgColor: src.bgColor || activePalette.bgColor,
        trackFillColor: src.trackFillColor || activePalette.trackFillColor,
        dotColor: src.dotColor || activePalette.dotColor,
        highlightColor: src.highlightColor || activePalette.highlightColor,
      });
      persistPalettes();
      renderInspector();
      toast('Palette saved: ' + name);
    }

    function applyPalette(idx, targetId) {
      const pal = savedPalettes[idx]; if (!pal) return;
      activePalette = {
        faceColor: pal.faceColor, ringColor: pal.ringColor,
        needleColor: pal.needleColor, labelColor: pal.labelColor,
        bgColor: pal.bgColor, trackFillColor: pal.trackFillColor,
        dotColor: pal.dotColor, highlightColor: pal.highlightColor
      };
      if (targetId) {
        const c = p.controls.find(c => c.id === targetId);
        if (c) {
          c.faceColor = pal.faceColor; c.ringColor = pal.ringColor;
          c.needleColor = pal.needleColor; c.labelColor = pal.labelColor;
          c.bgColor = pal.bgColor; c.trackFillColor = pal.trackFillColor;
          c.dotColor = pal.dotColor; c.highlightColor = pal.highlightColor;
        }
      }
      renderCanvas(); renderInspector();
    }

    function deletePalette(idx) {
      savedPalettes.splice(idx, 1);
      persistPalettes();
      renderInspector();
    }

    // Returns HTML string for the palette swatch strip (called inside template literal)
    function renderPaletteSwatches(targetId) {
      if (!savedPalettes.length) return '<div style="font-size:10px;color:var(--muted);margin-bottom:6px">No saved combos yet â€” save one below â†“</div>';
      const swatches = savedPalettes.map((pal, i) => `
                        <div title="${pal.name}" style="position:relative;display:inline-block">
                          <div class="swatch" onclick="applyPalette(${i},'${targetId}')"
                            style="background:linear-gradient(135deg,${pal.ringColor} 50%,${pal.faceColor} 50%)"
                            title="${pal.name} â€” click to apply"></div>
                          <div onclick="deletePalette(${i})" title="Delete" style="position:absolute;top:-4px;right:-4px;width:12px;height:12px;background:var(--accent3);border-radius:50%;font-size:8px;color:#fff;display:flex;align-items:center;justify-content:center;cursor:pointer;line-height:1">Ã—</div>
                        </div>`).join('');
      return `<div style="margin-bottom:6px">
                          <div style="font-size:9px;color:var(--muted);letter-spacing:.1em;text-transform:uppercase;margin-bottom:4px">Saved Combos â€” click to apply</div>
                          <div class="palette-row">${swatches}</div>
                        </div>`;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  UNDO / REDO SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const undoStack = [];
    const redoStack = [];
    const MAX_HISTORY = 50;

    function snapshot() {
      // Deep clone current state and push to undo stack
      undoStack.push(JSON.stringify({ p: clone(p), selID }));
      if (undoStack.length > MAX_HISTORY) undoStack.shift();
      // Any new action clears redo
      redoStack.length = 0;
      updateUndoRedoBtns();
    }

    function undo() {
      if (!undoStack.length) return;
      // Push current to redo
      redoStack.push(JSON.stringify({ p: clone(p), selID }));
      // Pop and restore
      const state = JSON.parse(undoStack.pop());
      p = state.p; selID = state.selID;
      syncSidebar(); renderCanvas(); renderCtrlList(); renderInspector();
      updateUndoRedoBtns();
      toast('Undo');
    }

    function redo() {
      if (!redoStack.length) return;
      undoStack.push(JSON.stringify({ p: clone(p), selID }));
      const state = JSON.parse(redoStack.pop());
      p = state.p; selID = state.selID;
      syncSidebar(); renderCanvas(); renderCtrlList(); renderInspector();
      updateUndoRedoBtns();
      toast('Redo');
    }

    function updateUndoRedoBtns() {
      const u = document.getElementById('undo-btn');
      const r = document.getElementById('redo-btn');
      if (u) { u.style.opacity = undoStack.length ? '1' : '.4'; u.style.cursor = undoStack.length ? 'pointer' : 'not-allowed'; }
      if (r) { r.style.opacity = redoStack.length ? '1' : '.4'; r.style.cursor = redoStack.length ? 'pointer' : 'not-allowed'; }
    }

    boot();
  </script>
</body>

</html>